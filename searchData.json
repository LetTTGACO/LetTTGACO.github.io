[{"title":"Nginx配置重定向和Https的实践","url":"/2020/10/16/Nginx配置重定向和Https的实践/","content":"\n## 引言\n\n在`docker`容器化越来越流行的今天，安装各种环境和软件都越来越方便。然而我的腾讯云服务器却依旧使用的是较为原始的`yum`等安装方式，后来换成了宝塔一键式安装后，网站也稳定运行着，也没有再去管了。然而今天发现云服务的内存占用都快满了，然而我还想安装一些其他环境。所以为了进一步榨干云服务的性能，我选择重装系统，全部利用`docker`的方式去安装各种环境。不过今天只记录下安装`nginx`及其一些配置时爬过的坑。\n\n我的博客`blog.letttgaco.cn`，是部署在`GitHub Pages`上的，但是域名备案时是备案的`www.letttgaco.cn`，所以我是想利用`nginx`的重定向功能，将`www.letttgaco.cn`重定向到我的博客去。\n\n## 思路\n\n在dns解析中，`blog.letttgaco.cn`已经指向的是`github`（GitHub Pages已设置强制HTTPS访问），现在需要将`www.letttgaco.cn`的`dns`解析指向云服务器上，然后由云服务器上部署的Nginx去监听80端口和443端口，将其重定向/转发至`https://blog.letttgaco.cn`。\n\n## 安装前准备\n\n我的云服务器为腾讯云服务器，系统为CentOS7.6(64位)，自带50G系统盘。\n\n在`dns`解析中将`www.letttgaco.cn`指向云服务器的对外IP地址。\n\n## 安装并配置Nginx\n\n首先介绍下整体的目录结构，如下：\n\n### 目录结构\n\n```sh\n|--root                   // root（家）目录\n|  |--app                 // 各个程序所在目录\n|  |  |--nginx            // 各个程序所在目录\n|  |  |  |--conf  \t\t\t\t\t\t\t\n|  |  |  |  |--nginx.conf // nginx自定义配置文件\n|  |  |  |--html          // 网页根目录\n|  |  |  |--logs          // 日志文件\n|  |  |  |--ssl           // 各个域名的证书存放地址nginx.conf\n|  |--nginx_run.sh        // sh自动化命令\n```\n\n首先先按照以上目录结构创建相应的文件夹和文件\n\n```sh\nmkdir /root/app/nginx/conf -p\ntouch /root/app/nginx/conf/nginx.conf\nmkdir /root/app/nginx/html -p\nmkdir /root/app/nginx/logs -p\nmkdir /root/app/nginx/ssl -p\ntouch /root/nginx_run.sh\n```\n\n### 配置文件\n\n#### 1.不需要SSL\n\n如果只需要将`http://www.letttgaco.cn`重定向到`https://blog.letttgaco.cn`，那就只需要配置80端口。\n\n```sh\nvim /root/app/nginx/conf/nginx.conf\n```\n\n```\nserver {\n    listen       80;\n\n    server_name  www.letttgaco.cn;\n    rewrite /.* https://blog.letttgaco.cn$uri permanent;\n}\n```\n\n备注：重定向的`url`是会发生变更，如果是需要隐式转发，则可以进行如下配置：\n\n```\nserver {\n    listen 80;\n    server_name www.letttgaco.cn;\n    large_client_header_buffers 4 128k;\n\n    location / {\n\n        #开启对http1.1支持\n        proxy_http_version 1.1;\n\n        #设置Connection为空串,以禁止传递头部到后端\n        #http1.0中默认值Connection: close\n        proxy_set_header Connection \"\";\n\n        proxy_pass https://blog.letttgaco.cn;\n    }\n}\n```\n\n#### 2.需要SSL\n\n如果也需要将`https://www.letttgaco.cn`也进行重定向，那么就需要进行额外的证书配置\n\n##### (1)申请SSL证书\n\n首先先去腾讯云去申请`www.letttgaco.cn`的SSL证书，主要有两个文件：\n\n- `1_www.letttgaco.cn_bundle.crt`\n- `2_www.letttgaco.cn.key`\n\n将证书下载下来并上传到`/root/app/nginx/ssl`中，\n\n> 备注：[腾讯云SSL部署文档](https://cloud.tencent.com/document/product/400/35244)\n\n##### (2)配置conf文件\n\n```\nserver {\n    listen 80;\n    #SSL 访问端口号为 443\n    listen 443 ssl;\n    #填写绑定证书的域名\n    server_name www.letttgaco;\n    #证书文件名称\n    ssl_certificate /ssl/1_www.letttgaco.cn_bundle.crt;\n    #私钥文件名称\n    ssl_certificate_key /ssl/2_www.letttgaco.cn.key;\n    ssl_session_timeout 5m;\n    #请按照以下协议配置\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n    ssl_prefer_server_ciphers on;\n\t\t# 重定向\n    rewrite /.* https://blog.letttgaco.cn$uri permanent;\n}\n```\n\n### 启动Nginx\n\n#### 1.不需要SSL\n\n```sh\ndocker run -p 80:80 --name nginx -v /root/app/nginx/html/:/usr/share/nginx/html -v /root/app/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf -v /root/app/nginx/logs/:/var/log/nginx/  --privileged=true -d nginx:1.19.3\n```\n\n#### 2.需要SSL\n\n```sh\ndocker run -p 80:80 -p 443:443 --name nginx -v /root/app/nginx/html/:/usr/share/nginx/html -v /root/app/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf -v /root/app/nginx/logs/:/var/log/nginx/ -v /root/app/nginx/ssl/:/ssl/ --privileged=true -d nginx:1.19.3\n```\n> `-p 80:80` 将80端口映射到主机80端口\n>\n> `--name nginx` 别名，可以使用别名操作nginx容器\n>\n> `-v /root/app/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf` 将主机的配置文件挂载到容器中，使nginx容器使用主机中的自定义配置文件\n>\n> `--privileged=true` 获取宿主机root权限\n>\n> `nginx:1.19.3` 指定nginx的版本，防止后续有坑\n\n## 自动化启动Nginx\n\n为了启动`Nginx`方便，我在这里写了一个简单的`nginx_run.sh`的脚本：\n\n```sh\ndocker stop nginx\ndocker rm nginx\ndocker run -p 80:80 -p 443:443 --name nginx -v /root/app/nginx/html/:/usr/share/nginx/html -v /root/app/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf -v /root/app/nginx/logs/:/var/log/nginx/ -v /root/app/nginx/ssl/:/ssl/ --privileged=true -d nginx:1.19.3\n```\n\n## 结束\n\n至此，我的网站终于可以实现`http`和`https`的重定向了。\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n","tags":["Nginx"],"categories":["技术分享","Linux"]},{"title":"Web开发过程中的图片优化","url":"/2020/04/20/Web开发过程中的图片优化/","content":"\n# Web开发过程中的图片优化\n\n图片是大部分网页的重要组成部分，一般情况下，我们不会太关注这方面的问题，需要显示图片直接一个 `img` 标签搞定。\n\n但实际上，无论是对于提高加载速度，还是对于优化用户体验，优化图片都是一个重要的手段。\n\n图片优化分成两个方面：\n\n第一，图片压缩。在保证视觉效果的情况下，减少图片的体积。这个很有效，1M 和 100K 的图片，肉眼看起来几乎差不多，但却省了 90% 的流量，大大提高了加载速度。\n\n第二，响应式图片。根据客户端的情况，选择最合适的图片返回给用户。用户是一个 500px 的设备，那么返回 1000px 的图给他就是浪费（假设物理像素和 CSS 像素是一比一）。\n\n我们先来看图片压缩。\n\n## 一、图片压缩\n\n压缩的第一步是筛选出需要压缩的图片。如果图片本身就已经足够小了，那么再压缩的意义就不大。\n\n而对于这些足够小的图片，我们就可以将其转换成雪碧图**（CssSprites）**或者`base64`编码来存储，而关于这两者的使用场景这里可以看一下这两篇文章（[不要滥用雪碧图sprite](https://www.cnblogs.com/joyho/articles/3715275.html)和[玩转图片Base64编码](https://www.cnblogs.com/coco1s/p/4375774.html)）。\n\n### url-loader\n\n这里我采用的是webpack里的`url-loader`插件进行处理，对于小于1kb的图片，将其转换成`base64`编码进行存储。\n\n```javascript\n{\n  test: /\\.(png|jpe?g|gif|svg)$/,\n  use: [{\n      loader: \"url-loader\", // 它封装了file-loader，所以可以使用两个loader的全部配置属性\n      options: {\n        limit: 1024,\n        esModule: false,\n        outputPath: 'images' // 设置图片的输出路径\n      }\n    }\n  ]\n},\n```\n\n> **参数说明**\n>\n> `limit`是转换成Base64的图片大小的零界点设置，单位为Byte，小于该数值的将进行转换。\n>\n> `esModule`是针对是否使用模块化框架的用户设定参数，默认为true。如果项目中没有使用模块化框架，建议要将这个属性关闭，避免出现图片资源超过limit，就变成[object Module]的问题。\n>\n> `outputPath`图片输出路径，将优化后的图片统一输出到该路径。\n\n### image-webpack-loader\n\n接下来就是压缩大一点的图片了，使用[image-webpack-loader](https://github.com/tcoopman/image-webpack-loader)进行进一步处理。\n\n```javascript\n{\n  test: /\\.(png|jpe?g|gif|webp|svg)$/,\n  use: [{\n      loader: \"url-loader\",\n      options: {\n        limit: 1024,\n        esModule: false,\n        outputPath: 'images'\n      }\n    },\n    {\n      loader: 'image-webpack-loader',\n      options: {\n        mozjpeg: {\n          progressive: true,\n          quality: 70 // 数值越高，质量越好\n        },\n        optipng: {\n          // enabled: false,\n          OptimizationLevel: 4 // 默认是3\n        },\n        pngquant: {\n          enabled：false,\n          // quality: [0.75,0.95],\n          // speed: 4\n        },\n        gifsicle: {\n          interlaced: true, // 默认：false 隔行扫描gif进行渲染\n        },\n        // webp: {\n        //   quality: 75\n        // }\n      }\n    }\n  ]\n},\n```\n> 如文档所说，[image-webpack-loader](https://github.com/tcoopman/image-webpack-loader)随附以下优化器，默认情况下会自动启用这些优化器：\n>\n> - [mozjpeg](https://github.com/imagemin/imagemin-mozjpeg) — 压缩JPEG图像\n> - [optipng](https://github.com/kevva/imagemin-optipng) — 压缩PNG图像\n> - [pngquant](https://github.com/imagemin/imagemin-pngquant) — 压缩PNG图像\n> - [svgo](https://github.com/kevva/imagemin-svgo) — 压缩SVG图像\n> - [gifsicle](https://github.com/kevva/imagemin-gifsicle) — 压缩GIF图像\n>\n> 和可选的优化器：\n>\n> - [webp](https://github.com/imagemin/imagemin-webp) —将JPG和PNG图像压缩为WEBP\n>\n> 可以通过指定禁用默认优化器`optimizer.enabled: false`，并将其放在选项中即可启用可选优化器。\n#### [imagemin-mozjpeg](https://github.com/imagemin/imagemin-mozjpeg)\n\nJPEG 根据显示方式的不同，分为两种：Progressive JPEG 和 Baseline JPEG。\n\nProgressive JPEG 会先加载模糊的整张图片，然后变的越来越清晰。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200429225431.jpg)\n\n而 Baseline JPEG 会先清晰地加载图片的一部分，然后慢慢显示剩余的部分。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200429225446.jpg)\n\n从视觉效果来说，Progressive JPEG 自然更好一些。但它也有一些缺点，比如它的解码速度比 Baseline JPEG 要慢，占用的 CPU 时间更多。\n\n如果是桌面浏览器，这点性能问题自然无所谓，但是如果是移动端，就不得不考虑。工程本来就是权衡的艺术。\n\n默认情况下，MozJPEG 生成的是 Progressive JPEG，可以通过 [选项](https://github.com/imagemin/imagemin-mozjpeg#progressive) 调整。\n\n#### [optipng](https://github.com/imagemin/imagemin-optipng)\n\n在研究文档的过程中发现一个有趣的问题，也可能是官网无意中的行为（真的吗？），官方文档为了说明其API中的禁用指定优化器功能`optimizer.enabled: false`，就在文档中写了这么一段代码：\n\n```javascript\n{\t\n// optipng.enabled: false will disable optipng\n\toptipng: {\n\t\tenabled: false,\n\t},\n  pngquant: {\n    quality: [0.65, 0.90],\n    speed: 4\n    }\n}\n```\n\n本来是一个举例说明，结果在我google的几乎所有用户的webpack配置中，大家都把`optipng`这个优秀的压缩工具给禁用了QAQ。\n\n实际上在压缩质量上来说，`optipng`是无损压缩，采用的是基于LZ/Huffman的DEFLATE算法，以减少图片IDAT chunk区域的数据来实现压缩图片，同样是无损压缩的工具还有**[pngcrush](https://pngcrush.com/)、[pngout](https://www.oschina.net/translate/4-free-tools-to-optimize-and-compress-png-images-without-loosing-quality?print)、advpng**。\n\n而[pngquant](https://github.com/kornelski/pngquant)和**[tinypng](https://tinify.cn/)、[ImageAlpha](https://github.com/kornelski/ImageAlpha)、[pngnq](https://github.com/stuart/pngnq)**等都是有损压缩，采用的是quantization算法，将24位的PNG图片转换为8位的PNG图片，减少图片的颜色数来实现图片压缩；\n\n具体可以参考[Laya 图片压缩](https://www.jianshu.com/p/83d00a7e2a4b)对于各个压缩工具的对比情况。\n\n但是呢，一般有损压缩的压缩率会大大高于无损压缩。就如png和jpg两者来说，png格式可以进行无损压缩，质量好、支持透明但是体积大，jpg的质量相对差一点但是体积很小，两者体积相差几乎在70%以上。所以具体的权衡取舍还是看个人实际应用场景。\n\n#### [pngquant](https://github.com/imagemin/imagemin-pngquant) \n\n正如上面所说，它是一个有损压缩，我这里为了演示，暂时禁用了它。\n\n> **参数说明(引用自[Laya 图片压缩](https://www.jianshu.com/p/83d00a7e2a4b))：**\n>  1.`quality`参数的作用是保证图片经过优化处理后，图片质量的取值范围（0~1）。取值越小，表示压缩比率越大，同时的图片的质量也就越差。在测试过程中发现，当设置最低取值为0.60或0.65时，部分图片的质量会严重下降，因此最终选择了0.70作为最低值。\n>  2.`speed`参数的设置决定了图片优化的执行速度，取值范围为1~10，默认值为4。其中10的执行速度最快，对应的压缩比率最小；而1的执行速度最慢，对应的压缩比率最大。在测试过程中发现，无论我设置哪一个值它们的执行时间都差不多，不过压缩比率确实1的最大，10的最小。\n>  实测效果：\n>  在设置quality的取值范围为0.70~0.95，以及speed为4的情况下，可以在尽可能不影响图片质量的前提下去缩减文件的大小。\n>  在测试过程中，我们以PNG-8品质为256的图片为例，最终的图片输出可以降低70%左右的大小（从3.78KB缩减到1.13KB）。\n\n#### [gifsicle](https://github.com/imagemin/imagemin-gifsicle)\n\n[gifsicle](https://github.com/imagemin/imagemin-gifsicle)一共有4个参数配置，我一般常用的就interlaced，即隔行扫描进行渲染，图片会自上而下渐进式加载。\n\n在上文中提到的Progressive和Baseline的区别中，progressive等同于`interlaced`，baseline 等同于 `not interlaced`，所以取舍自己决定。\n\n> 参数说明\n>\n> `optimizationLevel`是优化级别，默认值为1，取值范围在1-3。优化级别的高低决定图片的质量，较高的级别需要更长的时间，但可能会有更好的效果。\n>\n> 文档中给出了3种取值所做的事：\n>\n> 1：仅存储每个图像的更改部分。\n>\n> 2：还使用透明度进一步缩小文件。\n>\n> 3：尝试几种优化方法（通常速度较慢，有时效果更好）。\n>\n> `colors`是颜色减少的高低设置，是将每个输出GIF中的不同颜色数量减少到指定数值或者更少，取值范围在2-256之间。\n>\n> `buffer`是利用缓冲进行优化。\n\n#### [webp](https://github.com/imagemin/imagemin-webp)\n\n最后来看一下该插件的可选优化器Webp。\n\n> **参数说明**\n>\n> `quality`质量参数，将品质因数设置在`0`和之间`100`。是最常用，大多数场景下也只需要调整这一个参数即可。\n>\n> 其他参数可以参考[官方文档](https://github.com/imagemin/imagemin-webp#api)\n>\n> **注意**\n>\n> **在实际的使用中，发现这里存在一个容易被忽视的坑。**\n>\n> **image-webpack-loader 里的webp优化器只是针对已有的webp文件进行质量上的优化（或者说就不起作用，如果有研究出来的大佬麻烦评论告知哈），并不能把前面的png/jpg转成webp。官方文档有点误导到大家，导致许多图片优化的教程都把这个当成webp转换器，然而我实际试了下，并不能=.=。**\n\n至于webp的优化过程，我将在下文`优雅地使用WebP图片`中详细介绍。\n\n## 二、响应式图片\n\n所谓响应式图片，关键就一点：**根据客户端的情况返回最适合客户端的图片**。\n\n那么，在准备部署响应式图片的时候，会存在哪些情况呢？\n\n- 是否希望根据客户端情况返回不同的图片 **内容**?\n- 是否希望根据客户端情况返回不同的图片 **格式**？\n- 是否希望根据客户端情况返回不同的图片 **尺寸** ？\n- 是否希望优化高 **分辨率** 设备的体验？\n\n在 `picture` 标签出来之前，这些只能通过 JS 来实现，不仅代码而且丑陋能力也不全。但是现在，针对这些问题，我们有了一个完整的优雅的解决方案。\n\n### picture 标签\n\n`picture` 是 HTML5 新引入的标签，基本用法如下。\n\n```html\n<picture>\n  <source srcset=\"a.jpg\">\n  <source srcset=\"b.jpg\">\n  <img src=\"c.jpg\" >\n</picture>\n```\n\n我们可以这样理解，`picture` 标签会从 `source` 中选择最合适的一个，然后将它的 URL 赋值给 `img`。对于不认识 `picture` 的旧浏览器，他们会忽略 `picture`，只渲染 `img`，一切都不会有问题。\n\n注意：**`picture` 标签最后一定要包含一个 `img` 标签，否则，什么都不会显示。**\n\n现在我们逐一来看 `picture` 是怎样解决上面的四个问题。\n\n### 动态内容\n\n根据客户端的情况，我们来返回完全不同的两张图。这个很简单，使用 `source` 标签的 `media` 属性即可。\n\n如下代码会在小于 1024px 的时候显示 `img-center.jpg`，而在大于等于 1024px 的时候显示 `img-full.jpg`。\n\n```html\n<picture>\n  <source\n    media=\"(min-width: 1024px)\"\n    srcset=\"img-full.jpg\"\n  >\n  <img\n    src=\"img-center.jpg\" \n  >\n</picture>\n```\n\n### 动态尺寸\n\n如果希望浏览器能根据情况去请求不同尺寸的图片，我们需要提供两个信息：\n\n- 有哪些尺寸的图片\n- 图片显示的时候是什么尺寸\n\n下面的代码中，我们首先使用 `srcset` 属性指定有哪些图片，分别是图片名和图片的尺寸，这里注意单位不用 `px` 而是 `w`，用于表示图片的固有宽度。\n\n`sizes` 属性告诉浏览器，这个图片在不同的条件下会是什么样的宽度。这个属性用于给到浏览器提示，并不会真正的指定 `img` 的宽度，我们还是需要另外使用 CSS 来指定。\n\n这样，给定一个视口宽度，浏览器可以得知图片需要的宽度，然后根据 DPI 情况，在所有可选图片中选择最合适的一个。\n\n```html\n<img\n  src=\"img-400.jpg\"\n  sizes=\"(min-width: 640px) 60vw, 100vw\"\n  srcset=\"img-200.jpg 200w,\n      img-400.jpg 400w, \n      img-800.jpg 800w,\n      img-1200.jpg 1200w\"\n>\n```\n\n### 动态分辨率\n\n动态分辨率其实是动态尺寸的一种简化情况。\n\n根据显示器的 DPI 返回同一张图片的不同分辨率版本可以直接利用 `img` 标签的 `srcset` 属性。\n\n使用了如下的代码，浏览器会自动根据显示器的 DPI 来决定下载图片的哪个版本。\n\n在低 DPI 设备上，例如桌面显示器，浏览器会使用 img-200.jpg，而在高 DPI 设备上，例如手机，浏览器会使用 img-400.jpg。\n\n```html\n<img\n  srcset=\"img-200.jpg, \n          img-300.jpg 1.5x,\n          img-400.jpg 2x\"\n  src=\"img-400.jpg\" \n>\n\n<style type=\"text/css\">\n  img {\n    width: 200px;\n  }\n</style>\n```\n\n当然，我们也可以组合这几个选项。\n\n- 视口 >= 1280px 时\n\n  - 根据视口的具体宽度，返回不同尺寸的 *img-full* 图片\n  - 如果客户端支持 WebP，返回 WebP 格式\n\n- 视口 < 1280px 时\n\n  - 根据视口的具体宽度，返回不同尺寸的 *img* 图片\n- 如果客户端支持 WebP，返回 WebP 格式\n\ndwdwd\ndwdd\n```html\n<picture>\n  <source\n    media=\"(min-width: 1280px)\"\n    sizes=\"50vw\"\n    srcset=\"img-full-200.webp 200w,\n        img-full-400.webp 400w,\n        img-full-800.webp 800w,\n        img-full-1200.webp 1200w,\n        img-full-1600.webp 1600w,\n        img-full-2000.webp 2000w\"\n    type=\"image/webp\"\n  >\n  <source\n    media=\"(min-width: 1280px)\"\n    sizes=\"50vw\"\n    srcset=\"img-full-200.jpg 200w,\n        img-full-400.jpg 400w,\n        img-full-800.jpg 800w,\n        img-full-1200.jpg 1200w,\n        img-full-1600.jpg 1800w,\n        img-full-2000.jpg 2000w\"\n  >\n\n  <source\n    sizes=\"(min-width: 640px) 60vw, 100vw\"\n    srcset=\"img-200.webp 200w,\n        img-400.webp 400w,\n        img-800.webp 800w,\n        img-1200.webp 1200w,\n        img-1600.webp 1600w,\n        img-2000.webp 2000w\"\n    type=\"image/webp\"\n  >\n  <img\n    src=\"img-400.jpg\"\n    sizes=\"(min-width: 640px) 60vw, 100vw\"\n    srcset=\"img-200.jpg 200w,\n        img-400.jpg 400w,\n        img-800.jpg 800w,\n        img-1200.jpg 1200w,\n        img-1600.jpg 1600w,\n        img-2000.jpg 2000w\"\n  >\n</picture>\n```\n\n这里强烈建议自己动手，结合 [placeholder.com](https://placeholder.com/) 网站，生成一些图片来测试。毕竟，纸上得来终觉浅。\n\n## 三、优雅地使用WebP图片\n\n在使用webp图片之前，我们先来了解下webp格式的图片到底是怎样的。\n\n参考[将之前的项目图片进行了压缩](https://blog.liuguofeng.com/tag/图片)这篇文章的说明：\n\n> [WebP](https://developers.google.com/speed/webp/)是Google推出的一种相对较新的格式，旨在通过编码[无损](https://en.wikipedia.org/wiki/Lossless_compression)和[有损](https://en.wikipedia.org/wiki/Lossy_compression)格式的图像来提供较小的文件大小，使其成为JPEG和PNG的绝佳替代品。\n>\n> WebP图像的视觉质量通常与JPEG和PNG相当，但通常文件大小要小得多。例如，当我将屏幕截图从上面转换为WebP时，我得到了一个88 KB的文件，其质量与913 KB的原始图像相当。**减少90％！**\n>\n> 看一看下面三张图，你能分辨的出来吗？\n>\n> - [原始图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232154.png)\n>\n> - [优化后的图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232255.png)\n>\n> - [webp图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232329.webp)\n>\n> 就个人而言，视觉质量具有可比性，您所获得的节省很难被忽视。现在我们已经确定了尽可能使用WebP格式的价值，但是要注意是它不能完全取代JPEG和PNG。根据[caniuse.com](https://caniuse.com/#search=WebP)提供的数据显示，虽然浏览器中的WebP支持已经很普遍了，但是需要足够高的版本号才可支持。\n>\n> ![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419233351.png)\n>\n> 截止撰稿日(2020-04-20)，只有Safari还在试验中，也算是即将支持webp图片了。至于IE浏览器嘛，emmmm....一言难尽:slightly_smiling_face:\n>\n> 数据显示，全球有77.63%的用户使用支持WebP的浏览器。这意味着，通过提供WebP图像，您可以为77.63%的客户提高网页速度。\n>\n> 所以，在客户端支持的情况下，我们应该尽可能地使用 WebP 格式。\n\n### picture标签兼容优化\n\n#### 优化流程\n\n在开始讲针对webp图片的优化前，我想先梳理下开发流程。\n\n这里需要分两种情况：\n\n1. 全新网站的兼容优化\n2. 针对已有网站的兼容优化。\n\n如果是全新网站，而且设计师把各种图片都给到你了，那就完全不用担心图片转换问题，可以直接运用`picture`标签书写兼容格式，我这里就不再赘述。\n\n而本文主要讲的就是在图片格式不全的情况下，甚至是对已有目录的静态网站进行优化时该怎样的开发流程。\n\n第一个是顺序，在上面我尝试了在构建的同时利用image-webpack-loader可选的webp转换器，直接对现有jpg/png图片转换失败后，就暂时无法在缺失webp图片的情况下直接进行改造。\n\n所以现在的思路是：\n\n1. 将现有的图片全部转换成webp格式。\n2. 将已有的img标签全部替换成picture标签。\n3. 利用webpack的html-loader识别出所有图片格式的路径后并将其hash重命名后打包到同一文件夹下。\n\n下面将具体展开谈一下针对单入口的页面和多入口的页面的处理。\n\n#### 单入口页面\n\n对于单入口单页面的话，网站所用的图片原则上都只在一个文件夹。假设一个单页面网站的目录结构是这样的：\n\n```csharp\n|--dist  \t\t\t\t\t\t\t\t//打包后的路径\n|--src  \t\t\t\t\t\t\t\t//项目源代码目录\n|  |--css  \t\t\t\t\t\t\t//存放css样式表\n|  |--images  \t\t\t\t\t//存放网页所需的所有图片\n|  |--js  \t\t\t\t\t\t\t//存放javaScript代码\n|  |--index.html  \t\t\t//网页入口\n|--webpack.config.js  \t//webpack的配置文件\n|--package.json  \t\t\t\t//项目元数据，依赖包等信息\n|--package-loack.json   //依赖包具体版本信息\n|--webp.js   \t\t\t\t\t\t//下文中提到的转换图片的js\n```\n\n我们可以使用`imagemin-webp`官方文档所提供的方法：使用了`imagemin`和`imagemin-webp`来转换jpg/png。\n\n在根目录中新建`webp.js`文件\n\n```javascript\nconst imageminWebp = require('imagemin-webp')\nconst imagemin = require('imagemin');\n\nimagemin(['src/images/*.{jpg,png}'], {\n  destination: \"src/images\",\n  plugins: [\n    imageminWebp({\n      quality: 80\n    }),\n  ],\n})\n```\n\n这样就可以在根目录运行`node webp.js`，把项目中的所有jpg/png转成webp格式图片并存放到原图片目录下，然后就可以对原有img标签进行改造，加上webp格式的图片。\n\n#### 多入口页面\n\n对于让人头疼的多入口页面来说，配置起来就复杂的多。首先我们先约定一下多入口页面的目录结构。\n\n##### 目录结构\n\n多入口也就意味着多出口，不但html网页可能分布在不同的文件夹下，不同网页所需的图片/css/js也被存放到对应网页的不同文件夹下。假设一个多入口页面的目录结构如下：\n\n```csharp\nwebpack\n|--dist  \t\t\t\t\t\t\t\t//打包后的路径\n|--src  \t\t\t\t\t\t\t\t//项目源代码目录\n|  |--common\t\t\t\t\t\t//存放各个页面都有可能用到的组件库（基本不变更）\n|  |  |--jquery.min.js  \n|  |  |--swiper.min.js  \n|  |--css  \t\t\t\t\t\t\t//存放css样式表\n|  |  |--index.scss  \t\t//index页面所需的样式表\n|  |  |--about.scss  \t\t//about页面所需的样式表\n|  |  |--common.scss  \t//通用样式表\n|  |--images  \t\t\t\t\t//存放网页所需的所有图片\n|  |  |--index  \t\t\t\t//index页面所需的图片\n|  |  |  |--header1.png  \n|  |  |  |--banner1.png  \n|  |  |  |--a1.jpg  \t  \n|  |  |  |--...\n|  |  |--about  \t\t\t\t//about页面所需的图片\n|  |  |  |--header1.png  \n|  |  |  |--banner1.png  \n|  |  |  |--a1.jpg  \t  \n|  |  |  |--...\n|  |  |--common  \t\t\t\t//可复用的图片\n|  |  |  |--logo.png  \n|  |  |  |--footer.png  \n|  |  |  |--wechat.svg  \t  \n|  |  |  |--...  \n|  |--js  \t\t\t\t\t\t\t//存放javaScript代码\n|  |  |--index.js  \t\t\t//index页面的js文件\n|  |  |--about.js  \t\t\t//index页面的js文件\n|  |  |--common.js  \t\t//可复用的js\n|  |--index.html  \t\t\t//网站首页html\n|  |--about.html  \t\t\t//关于网站html\n|--webpack.config.js  \t//webpack的配置文件\n|--package.json  \t\t\t\t//项目元数据，依赖包等信息\n|--package-loack.json   //依赖包具体版本信息\n```\n可以看出，较为复杂的就是图片了。由于多个页面所需的图片数量非常多，在开发的过程中很难保证图片起名的不重复，所以最理想的就是放在不同文件夹下了。\n\n但是新的问题出现了：webpack常用于将不同文件都打包至同一目录下，如果打包后命名重复导致文件被覆盖了怎么办？\n\n当然，webpack也给出了几乎完美的解决方案：将文件进行hash重命名后输出，这样就几乎不会导致重名覆盖问题的发生。\n\n可是，又一个棘手的问题发生了：\n\n上文我们也说了，我们是要在打包前就将图片转换成webp格式。这样改造过程中，静态资源的文件名也不会变，路径也是各自的路径，开发过程才能方便起来。\n\n那么，既然用到的图片会重名，所以将图片整体拿出来手动转换后再丢回到各自文件夹的方法也不可取。最理想的就是各自转换各自的目录，所以第一个办法就是：\n\n- 用单页面转换的方式，每次改一下输入输出路径，对每个存放图片的文件夹单独转换。\n\n怎么说呢，可以是可以的，但是既然都用了webpack自动化打包了，我们应该减少手动操作文件的次数。而且后期维护起来，那是相当的麻烦。当你有更多的页面，每次需求方更新图片的时候，我们都得手动操作一次，费力又费时间。\n\n##### gulp\n\n于是乎我投向了gulp的怀抱，gulp在操作文件的过程中，借鉴了linux的管道思想，可以将上个的输出作为下一个的输入。于是，基于gulp的自动化转换程序诞生了：\n\n首先在根目录建立gulpfile.js文件，并安装好所需的依赖。\n\n> **注意，gulp需要安装两次**\n>\n> ```js\n> npm i gulp -D //保证依赖被安装到node_modules下\n> npm i gulp -g //保证直接在命令行使用gulp命令时不会报错\n> ```\n\n```javascript\nconst gulp = require('gulp');\nconst fs = require('fs');\nconst merge = require('merge-stream');\nconst path = require('path');\nconst webp = require('gulp-webp');\n// 获取文件夹\nfunction getFolders(dir) {\n    return fs.readdirSync(dir)\n        .filter(function (file) {\n            return fs.statSync(path.join(dir, file)).isDirectory();\n        });\n}\n\n// 需要转换的文件路径，我这里设置为根目录下的src目录\nconst scriptsPath = path.resolve(__dirname, 'src')\n\nfunction imagesToWebp() {\n    const folders = getFolders(scriptsPath);\n    const tasks = folders.map(function (folder) {\n        console.log(folder)\n      \t//依次输出：\n      \t//common\n\t\t\t\t//css\n\t\t\t\t//images\n\t\t\t\t//js\n      \t// /**/*.{jpg,png}是找到src下所有层级的jpg/png图片\n        return gulp.src(path.join(scriptsPath, folder, '/**/*.{jpg,png}'))\n            .pipe(webp()) //使用webp插件进行转换（默认会保留原图片）\n            .pipe(gulp.dest(scriptsPath + folder)); //输出到各自的文件夹下\n    })\n    return merge(tasks); //合并gulp流\n}\n\nexports.webp = gulp.series(\n    imagesToWebp\n)\n```\n\n大功告成！这样我们就可以在命令行使用`gulp webp`命令进行图片转换了。\n\n在拿到了所有webp文件后，就可以使用picture标签进行改造了。\n\n```html\n<picture>\n  <source srcset=\"./images/index/a1.webp\" type=\"image/webp\">\n  <img src=\"./images/index/a1.png\">\n</picture>\n\n<picture>\n  <source srcset=\"./images/about/a1.webp\" type=\"image/webp\">\n  <img src=\"./images/about/a1.png\">\n</picture>\n```\n\n> **注意：**\n>\n> 记得在webpack.config.js中使用html-loader时，将source标签下的srcset属性加入attrs，否则html-loader将无法识别source标签中的图片路径。\n>\n> ```js\n> {\n>         test: /\\.(html)$/,\n>         use: {\n>           loader: 'html-loader',\n>           options: {\n>             root: path.resolve(__dirname, 'src'),\n>             attrs: ['img:src', 'img:data-src', 'source:srcset']\n>           }\n>         }\n>       }\n> ```\n\n对于webpack中关于多页面的其他配置，我将在其他文章中详细介绍并分享我的代码，请持续关注，谢谢～\n\n### 利用cdn服务自动判断\n\n目前，有些图片cdn服务可以开启自动兼容webp的模式，即支持webp的浏览器则将原图转换为webp图片并返回，否则直接返回原图。实现这个功能的原理是，根据浏览器发起的请求头中的Accept属性中是否包含webp格式来判断：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200429225140.png)\n\n有则说明浏览器支持webp格式，这对开发者来说可能是最简单的兼容方案，但是依赖于后端服务。\n\n## 四、参考\n\n1. [将之前的项目图片进行了压缩](https://blog.liuguofeng.com/tag/图片)\n2. [谈谈Web应用中的图片优化技巧及反思](https://juejin.im/post/5d4979cc5188255b3e4126ae#heading-10)\n3. [Laya 图片压缩](https://www.jianshu.com/p/83d00a7e2a4b)\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["图片优化"],"categories":["技术分享","前端"]},{"title":"谈一谈二进制","url":"/2020/04/17/谈一谈二进制/","content":"\n# 谈一谈二进制\n\n## 1.二进制与十进制之间的转换\n\n### 1.1十进制转换成二进制\n\n#### (1)整数十进制  => 二进制\n\n##### 取余法\n\n```java\npublic void test1() {\n  String numstr = \"\";\n  int de = 31;\n  while (de > 0) {\n    int res = de % 2; //除2 取余数作为二进制数\n    numstr = res + numstr;\n    de = de / 2;\n  }\n  System.out.println(numstr); //11111\n}\n```\n\n> 十进制整数转换为二进制整数采用\"除2取余，逆序排列\"法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。\n\n原理:假设十进制整数A化得的二进制数为`abcde`的形式，那么用上面的方法按权展开， 得\n\n`A=a(2^4)+b(2^3)+c(2^2)+d(2^1)+e(2^0)` （后面的和不正是化十进制的过程吗）\n\n假设该数未转化为二进制,除以基数`2`得\n\n`A/2=a(2^4)/2+b(3^1)/2+c(2^2)/2+d(1^3)/2+e(2^0)/2`\n\n注意：`e`除不开二，余下了！其他的绝对能除开，因为他们都包含`2`，而`e`乘的是`1`，他本身绝对不包含因数`2`，只能余下。所以可以得到余数`e`，`A/2 - e/2` 得到新的整数`a(2^3)+b(2^2)+c(2^1)+d(2^0)`，然后 再除以基数`2`余下了`d`，以此类推。当这个数不能再被`2`除时，先余掉的`e`位数在原数低，而后来的余数数位高，所以要把所有的余数反过来写。正好是`abcde`\n\n##### 移位异或法\n\n```java\npublic void test2() {\n  int num = 31;\n  //定义一个String用于返回得到的二进制\n  String binary = \"\";\n  while (num > 0) {\n    //获取每一位\n    int bit = num & 1;\n    //将获取的位添加到字符串\n    binary = bit + binary;\n    //向右移一位\n    num = num >> 1;\n  }\n  System.out.println(binary);\n}\n```\n\n> 这种位运算运用了一个特点：任何二进制数与1进行与运算都会得到其最低的低位有效位，即二进制数的最后一个数本身。所以让这个正整数与1进行与运算，再右移一位后把最后一位消除掉（整数/2），再进行如此的循环操作就可以得到这个正整数的每一位二进制数，因为先运算的数位低，后运算的高，所以进行一个反向排列就可以得到该正整数对应的二进制数。\n\n\n\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["数据结构"],"categories":["填坑之路"]},{"title":"canal命令总结","url":"/2020/04/15/canal命令总结/","content":"\n# canal命令总结\n\n### 查看端口：netstat -ntulp\n\n## canal\n\n```\n路径：/root/canal\n配置文件：vim /root/canal/conf/example/instance.properties\n启动：sh /root/canal/bin/startup.sh\n关闭：sh /root/canal/bin/stop.sh\nserver日志：tail -100f logs/canal/canal.log\nnstance日志：tail -100f logs/example/example.log\n删除日志：rm -rf logs/canal/canal.log logs/example/example.log\n端口：119.27.172.40:11111\n```\n\n## zookeeper\n\n```\n路径：/usr/local/zookeeper\n配置文件：vim conf/zoo.cfg\n启动：bin/zkServer.sh start\n关闭：bin/zkServer.sh stop\n状态：zkServer.sh status\n验证：telnet 127.0.0.1 2181\n\t\t stat\n关闭：./zkServer.sh stop\n端口：119.27.172.40:2181\n```\n\n### zkui\n\n```\n路径：/root/zkui\n配置文件：vim config.cfg\n配置文件：vim target/config.cfg\n前台启动：java -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar\n后台启动：nohup java -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar & \n端口：119.27.172.40:9090\n```\n\n## kafka\n\n```\n路径：/usr/local/kafka/kafka_2.11-1.1.1\n配置文件：vim config/server.properties\n启动server：bin/kafka-server-start.sh  -daemon  config/server.properties &\n关闭server：bin/kafka-server-stop.sh\n查看所有topic：bin/kafka-topics.sh --list --zookeeper 119.27.172.40:2181\n查看指定topic下面的数据：\nbin/kafka-console-consumer.sh --bootstrap-server 119.27.172.40:9092  --from-beginning --topic example_t\n端口：119.27.172.40:9092\n```\n\n","tags":["canal","中间件"],"categories":["技术分享","后端"]},{"title":"Tinymce-Vue初体验","url":"/2020/03/07/Tinymce-Vue初体验/","content":"\n# Tinymce-Vue初体验\n\n最近有需求需要用到富文本编辑器，而且需要将上传/粘贴的图片上传到阿里云OSS上。在简单体验了几个富文本编辑器之后，决定选用Tinymce。\n\n## Tinymce-Vue\n\nTinymce-Vue里面的坑还是挺多的，花了两天时间终于把一些简单的坑填上了，基本上算是满足了需求。这里来简单讲一下在项目中使用 `Tinymce-Vue` 的经过。\n\n### Tinymce-Vue插件安装\n\n```shell\nnpm install @tinymce/tinymce-vue -D\nnpm install tinymce -D\n```\n\n安装成功之后，在`node_modules`目录中，找到`tinymce`中的`skins`目录，将其拷贝到`static`或者`public`目录下。为了结构清晰，我外层包了`tinymce`目录。\n\n> 踩坑①：用不同版本的`vue-cli`创建出来的项目，默认静态公共资源的目录是不一样的。`vue-cli2`的默认静态公共资源目录为`static`，但是`vue-cli3`默认为`public`。拷贝的时候根据自己项目的配置注意下\n\n由于`tinymce`默认是英文界面，如果需要下载[中文的语言包](https://www.tiny.cloud/get-tiny/language-packages/)，可以去官网下载。下载之后将其放在`public/tinymce/`下。同样的，为了结构清晰，我将其放在了`langs`目录下。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/tinymce1.png)\n\n### 起步\n\n在组件中初始化`Tinymce.vue`组件，并引入需要用到的依赖。\n\n```javascript\n// 引入基本文件\nimport tinymce from 'tinymce/tinymce'\nimport Editor from '@tinymce/tinymce-vue'\n// 引入主题文件\nimport 'tinymce/themes/silver'\n// 引入你需要的插件\nimport 'tinymce/plugins/paste' //粘贴插件，很强大，配置后可以粘贴图片\nimport 'tinymce/plugins/image' //上传图片的插件\nimport 'tinymce/plugins/table' //表格\nimport 'tinymce/plugins/wordcount'\n```\n\n由于`Editor-vue`也是官方封装的组件，所以需要注册组件使用。\n\n```javascript\ncomponents: {\n    Editor\n}\n```\n\n使用组件，代码如下：\n\n```html\n<template>\n  <div class=\"tinymce-editor\">\n    <editor\n      :key=\"tinymceFlag\"\n      class=\"editor\"\n      v-model=\"myValue\"\n      :init=\"tinymceInit\">\n    </editor>\n    <a-button @click=\"handleSubmit\" type=\"primary\" class=\"button\">{{ label }}</a-button>\n  </div>\n</template>\n\n<script>\n// 引入基本文件\n// eslint-disable-next-line no-unused-vars\nimport tinymce from 'tinymce/tinymce'\nimport Editor from '@tinymce/tinymce-vue'\n// 引入主题样式\nimport 'tinymce/themes/silver'\n// 引入你需要的插件\nimport 'tinymce/plugins/paste'\nimport 'tinymce/plugins/image'\nimport 'tinymce/plugins/table'\nimport OSS from '@/utils/oss.js'\nimport v1 from 'uuid'\n\nexport default {\n  name: 'Tinymce',\n  data () {\n    return {\n      tinymceFlag: 1,\n      myValue: '',\n      isShowFileDlg: false,\n      tinymceInit: {}\n    }\n  },\n  props: {\n    // 基本路径，默认为空根目录，如果你的项目发布后的地址为目录形式，\n    // 即abc.com/tinymce，baseUrl需要配置成tinymce，不然发布后资源会找不到\n    // 我也不知道为啥要设置baseUrl，我目前没有遇到这个问题。等遇到再说\n    baseUrl: {\n      type: String,\n      default: ''\n    },\n    // 定义允许上传的图片类型\n    accept: {\n      default: 'image/jpeg, image/png',\n      type: String\n    },\n    // 最大上传图片大小\n    maxSize: {\n      default: 5242880,\n      type: Number\n    },\n    // 偶尔会需要禁用富文本\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    // 设置默认需要的拓展\n    plugins: {\n      type: [String, Array],\n      default: 'image table wordcount'   // 可以按照自己需要配置默认需要的组件\n    },\n   \t// 设置默认菜单栏 ‘|’ 用来分隔功能\n    toolbar: {\n      type: [String, Array],\n      default: 'undo redo | formatselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | image table'\n    },\n    // 自己项目需要做一个类似提交表单的按钮\n    label: {\n      type: String,\n      default: '提交'\n    },\n    // 设置默认宽度\n    width: {\n      type: String,\n      default: '1200'\n    },\n    // 设置默认高度\n    height: {\n      type: String\n    }\n  },\n  components: {\n    Editor\n  },\n  mounted () {\n  },\n  created () {\n    // 定义self防止this调用时指向性问题\n    const self = this\n    self.tinymceInit = {\n      fontsize_formats: '11px 12px 14px 16px 18px 24px 36px 48px 50px 56px 60px 64px',\n      language_url: `/tinymce/langs/zh_CN.js`, // 设置中文语言的路径，我的是/public下的tinymce\n      skin_url: '/tinymce/skins/ui/oxide', // skin路径\n      language: 'zh_CN',\n      width: this.width,\n      browser_spellcheck: true, // 拼写检查\n      branding: false, // 去水印\n      statusbar: false, // 隐藏编辑器底部的状态栏\n      paste_data_images: true, // 允许粘贴图像\n      menubar: false, // 隐藏最上方menu\n      plugins: this.plugins,\n      toolbar: this.toolbar,\n      // 设置图片上传时的上传函数，支持图片复制粘贴前上传到指定服务器然后返回url到富文本\n      images_upload_handler: (blobInfo, success, failure) => {\n        if (blobInfo.blob().size > self.maxSize) {\n          failure('文件体积不能超过' + this.maxSize / (1024 * 1024) + 'Mb')\n        }\n        if (self.accept.indexOf(blobInfo.blob().type) >= 0) {\n          uploadPic()\n        } else {\n          failure('图片格式错误, 仅支持' + this.accept + '格式的图片')\n        }\n        // 异步上传到OSS\n        async function uploadPic () {\n          if (self.client) {\n            //值得注意的是，测试时，微信截图后直接在富文本进行粘贴后会出现OSS文件类型报错，需要传入Buffer流或者Blob文件，可blobInfo.blob()按道理应该是blob才对，可还是报错，无奈做了一个blobInfo.blob()的带的File文件对象 ==》 ArrayBuffer流 ==》 Buffer流 才使得OSS能够识别。\n            const reader = new FileReader()\n            reader.readAsArrayBuffer(blobInfo.blob()) // File文件对象 ==》 ArrayBuffer流\n            reader.onload = function (event) {\n              console.log(event.target.result)\n              // 引入UUID防止文件覆盖\n              const fileName = `${v1()}-${blobInfo.name()}`\n              self.client\n                // ArrayBuffer流 ==》 Buffer流 ==》 OSS.put()\n                .put(fileName, toBuffer(event.target.result))\n                .then(result => {\n                  // 得到OSS返回的url\n                  result.url = result.res.requestUrls[0].split('?')[0]\n                  // 将上传完成的状态抛出\n                  self.$emit('on-upload-complete', result) // 抛出 'on-upload-complete' 钩子\n                  // 返回url\n                  success(result.url)\n                })\n                .catch(err => {\n                  // 失败\n                  failure(err)\n                })\n            }\n          } else {\n            // 封装的OSS的错误提示（ak失效时触发）\n            await self.$message.info('上传配置已失效，重新加载中...')\n          }\n          return {\n            failure () {}\n          }\n          // ArrayBuffer流 ==》 Buffer流\n          function toBuffer (ab) {\n            const buf = Buffer.alloc(ab.byteLength)\n            const view = new Uint8Array(ab)\n            for (let i = 0; i < buf.length; ++i) {\n              buf[i] = view[i]\n            }\n            return buf\n          }\n        }\n      }\n    }\n  },\n  watch: {\n    myValue (newValue) {\n      this.$emit('input', newValue)\n    }\n  },\n  activated () {\n    // 当使用keep-alive时，在切换标签页再切回来会出现富文本key缺少无法使用的情况，在这个里做一个处理，让每次的key不一样\n    this.tinymceFlag++\n  },\n  methods: {\n    // 自己的业务需求需要一个提交按钮，将值传回父组件\n    handleSubmit () {\n      this.$emit('submit', this.myValue)\n    }\n  },\n  computed: {\n    // 封装的OSS的初始化方法\n    client: function () {\n      return OSS.client()\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  .tinymce-editor {\n    margin-left: 30px;\n    .button {\n      margin-top: 15px;\n      float: right;\n    }\n  }\n</style>\n```\n\n> 坑②：当使用`keep-alive`时，富文本会出现`key`重复的问题\n>\n> 坑③：微信截图完直接粘贴图片后`blobInfo.blob()`生成一个不能被`OSS`识别的`File`对象，需要`File`文件对象 ==》 `ArrayBuffer`流 ==》 `Buffer`流 才能被`OSS`识别\n\n\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["Tinymce"],"categories":["技术分享","前端"]},{"title":"Git常用命令","url":"/2020/03/01/Git常用命令/","content":"\n# Git常用命令\n\n记录学习一下每天都在使用的Git操作命令，以加快工作效率、应对意外情况的发生为目标。\n\n![Git常用命令](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/Git常用命令.png)\n\n```\n  - Workspace：工作区\n  - Index / Stage：暂存区\n  - Repository：仓库区（或本地仓库）\n  - Remote：远程仓库\n```\n\n  \n\n## git stash\n`git stash`的应用场景有以下几种情况，我都遇到过，以往我都是把代码复制出来再改BUG，今天才发现这么做简直很蠢QAQ。\n\n- 发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑`git stash`。\n\n- 使用git的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码`commit`提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用`git stash`就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用`git stash apply`将以前一半的工作应用回来。\n\n- 经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是`git stash`命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。\n\n`git stash`会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。\n比如下面的中间状态，通过git stash命令推送一个新的储藏，当前的工作目录就干净了。而且`git stash`是本地存储，并不会推送到服务器。\n\n```shell\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n$ git stash\nSaved working directory and index state WIP on master: e4f060f add readme\n\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n### 1. git stash save\n\n实际应用中推荐给每个stash加一个message，用于记录版本，使用`git stash save`取代`git stash`命令。\n\n```shell\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n$ git stash save '改了index的标题'\nSaved working directory and index state On master: 改了index的标题\n\n$ git status\nOn branch master\nnothing to commit, working tree clean\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n```\n\n### 2. git stash apply\n\ngit stash apply用于将缓存堆栈中的stash恢复到工作目录中，但并不删除stash拷贝。也可以使用`git stash apply stash@{1}` 指定恢复某个`stash`，不加参数默认最近的一个stash，即`git stash apply stash@{0}`\n\n```shell\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash apply stash@{1}\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n```\n\n### 3. git stash pop\n\n和`apply`作用类似，这个指令可以将缓存堆栈中的第一个`stash`删除，并将对应修改应用到当前的工作目录下。\n\n```shell\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\nstash@{3}: WIP on master: e4f060f add readme\n\n$ git stash pop\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (91bfd4fd55e0e3f90a480dfc5bebe0394a393860)\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n\n\n```\n\n### 4. git stash drop\n\n用于移除缓存堆栈中的第一个`stash`，也可以指定删除某一个`stash`\n\n```shell\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\nstash@{3}: WIP on master: e4f060f add readme\n\n$ git stash drop\nDropped refs/stash@{0} (22b04ba90a37fb36d5f8e7228e7d8cee324a148b)\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash drop stash@{2}\nDropped stash@{2} (33d9570595f16bc5f4a07247551377e10a0a6ce1)\n\n$ git stash  list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\n```\n\n### 5. git stash show\n\n用于查看最近一个或者指定`stash`的diff，貌似用到的不多，记录下。`git stash show -p`可以查看特定`stash`的全部`diff`以及更人性化一点，\n\n```shell\n$ git stash  list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash show\n index.html | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n$ git stash show stash@{2}\n index.html | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n \n$ git stash show -p\ndiff --git a/index.html b/index.html\nindex 79c2914..47be827 100644\n--- a/index.html\n+++ b/index.html\n@@ -5,9 +5,9 @@\n......\n```\n\n### 6. git stash branch\n\n这条命令会根据最近的 `stash` 创建一个新的分支，然后删除最近的 `stash`（和 `stash pop` 一样）。如果你需要某个 `stash`，你可以指明 `stash id`。\n\n```shell\n# git_learning (master)\n$ git stash\nSaved working directory and index state WIP on master: e4f060f add readme\n\n# git_learning (master)\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\n\n# git_learning (master)\n$ git stash branch testbranch\n# 或者指定id \n#$ git stash branch testbranch stash@{0}\nSwitched to a new branch 'testbranch'\nOn branch testbranch\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (e943a81398f2f01a2d64b227488af67a49b78e57)\n\n# git_learning (testbranch)\n$ git stash list\n# 无,被删除了\n```\n\n### 7. 小结\n\n默认情况下，`git stash`会缓存下列文件：\n\n- 添加到暂存区的修改（`staged changes`）\n- Git跟踪的但并未添加到暂存区的修改（`unstaged changes`），即`git add` 但未 `git commit`\n\n但不会缓存一下文件：\n\n- 在工作目录中新的文件（`untracked files`）\n- 被忽略的文件（`ignored files`）\n\n`git stash`命令提供了参数用于缓存上面两种类型的文件。使用`-u`或者`--include-untracked`可以缓存`stash untracked`文件。使用`-a`或者`--all`命令可以stash当前目录下的所有修改。\n\n\n\n## git checkout\n\n### 1. 基础用法\n\n`checkout`最常用的用法莫过于对于工作分支的切换了：\n\n`git checkout branchName`只是将项目切换到任意分支，不创建分支。\n\n除非再`git clone` 一个新的项目后，因为只会默认在本地创建一个`master`分支，这个时候想要切换到远程分支的话，一般是创建该分支的本地分支并切换到该分支。\n\n```\n创建新分支：git branch branchName\n\n切换到新分支：git checkout branchName\n```\n\n但是大多数情况下都是创建分支的时候切换分支。所以以上语句可以合成一句话：\n\n`git checkout -b branchName`\n\n### 2. 进阶\n\n要想更深入的了解`checkout`，我们需要了解`checkout`的作用机制。该命令的主要关联目标其实是`.git` 文件夹下的`HEAD`文件。\n\n我们可以看到`HEAD`头文件是一个引用，指向的是当前的分支，如果变更分支，该`HEAD`会变更。\n\n```shell\n# git_learning (master)\n$ cd .git/\n\n# git_learning/.git (GIT_DIR!)\n$ ls\nCOMMIT_EDITMSG  description  gitk.cache  hooks/  info/  objects/   refs/\nconfig          FETCH_HEAD   HEAD        index   logs/  ORIG_HEAD\n\n# git_learning/.git (GIT_DIR!)\n$ cat HEAD\nref: refs/heads/master\n\n# git_learning/.git (GIT_DIR!)\n$ cd refs/heads/\n\n# git_learning/.git/refs/heads (GIT_DIR!)\n$ ls\n111  master  new_branch  testbranch\n\n# git_learning/.git/refs/heads (GIT_DIR!)\n$  cat master\ne4f060f544371c8adab70af931ba008024bdc2e1\n\n# git_learning (master)\n$ git checkout 111\nSwitched to branch '111'\n\n# git_learning (111)\n$ cat .git/HEAD\nref: refs/heads/111\n```\n\n\n\n.....\n\n持续记录中QAQ\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["Git"],"categories":["技术分享"]},{"title":"HBase集群搭建过程中容易出现的Bug汇总及解决方案","url":"/2019/05/14/HBase集群搭建过程中容易出现的Bug汇总及解决方案/","content":"\n## 前言\n\n最近在搭建Hadoop+zookeeper+HBase集群过程中，HBase老是出现各种问题，经过不断查看日志文件，找各种解决办法......此时此时，我终于是搭建成功了吼吼吼~值得庆祝一下。以下是我在搭建HBase集群过程中出现的问题记录，改天抽空写一下Hadoop+zookeeper+HBase的集群搭建。\n\n### hbase-site.xml\n\n先放一下最后搞定成功的配置文件\n\n```xml\n<!-- 设置HRegionServers共享目录。因为我搭建的是高可用集群，\n\t所以这里的hbase.rootdir值来自hadoop中的hdfs.default的值 -->\n<property>\n\t<name>hbase.rootdir</name>\n\t<value>hdfs://mycluster/hbase</value>\n</property>\n<!-- 启用分布式模式 -->\n<property>\n\t<name>hbase.cluster.distributed</name>\n\t<value>true</value>\n</property>\n<!-- master主机的端口号 -->\n<property>\n\t<name>hbase.master</name>\n\t<value>mycluster:60000</value>\n</property>\n<!-- 指定Zookeeper集群位置 -->\n<property>\n\t<name>hbase.zookeeper.quorum</name>\n\t<value>s201:2181,s202:2181,s203:2181</value>\n</property>\n <!-- 指定独立Zookeeper安装路径 -->\n<property>\n\t<name>hbase.zookeeper.property.dataDir</name>\n\t<value>/home/letttgaco/zookeeper</value>\n</property>\n<!-- 指定ZooKeeper集群端口 -->\n<property>\n\t<name>hbase.zookeeper.property.clientPort</name>\n\t<value>2181</value>\n</property>\n```\n\n### Bug汇总\n\n####  （1）java.net.UnknownHostException: MyCluster\n\n这是因为，HBase没有识别MyCluster这个集群，解决这个问题的方法是把Hadoop的2个配置文件（`core-site.xml`和`hdfs-site.xml`），放到每个HBase的conf目录下，让HBase能找到Hadoop的配置。\n\n#### （2）zookeeper.MetaTableLocator: Failed verification of hbase:meta,,1 at address xxx\n\n如果你也是集群搭建过程中出现这个问题，请清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n#### （3）ERROR: org.apache.hadoop.hbase.ipc.ServerNotRunningYetException: Server is not running yet\n\n如果你也是集群搭建过程中出现这个问题，请清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n#### （4）org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby \n\n这是由于启动hbase时，namenode所在节点的主机的hadoop状态为standby（备用）态，hbase master进程会在启动后自动停掉。我出现这个的原因是：我虽然准备搭建hbase集群，但是在`hbase-site.xml`配置文件中的`hbase.rootdir`属性中配置的依然是单一某个主机节点的共享目录，导致在standby态的主机启动hbase坏掉。所以解决方案是参照我的配置文件进行修改，清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后重新启动`start-hbase.sh`。\n\n#### （5）exception=org.apache.hadoop.hbase.NotServingRegionException: Region hbase:meta,,1 is not online on xxx\n\n即使我已经搭建好的集群，我每次启动还是会报这个错误，但是并不影响正常运行。。。\n\n如果你是集群搭建过程中出现这个问题，请清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n#### （6）org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.fs. PathIsNotEmptyDirectoryException): `/hbase/WALs/xxx-splitting is non empty': Directory is not empty\n\n我出现的原因是配置文件配错，在hbase-site.xml配置文件中的`hbase.rootdir`属性中配置的依然是单一某个主机节点的共享目录，所以hbase只会访问单一节点的hdfs 的 `/hbase/WALs/` 目录，导致冲突。解决方案是：请清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n------\n\n持续更新中，后面会重新搭建一次Hadoop+zookeeper+HBase集群，并记录所有Bug。\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["HBase"],"categories":["BUG记录"]},{"title":"Centos命令提示符显示完整路径","url":"/2019/05/04/Centos命令提示符显示完整路径/","content":"\n## 前言\n\nLinux下，命令行显示路径仅最后一个文件名，非常不方便， 最近在学大数据的时候才偶然发现这个小细节，简直太省心了，记录一下。\n\n## Centos命令提示符显示完整路径\n\n#### 1、编辑`[/etc/profile]`文件，在末尾添加环境变量PS1\n\n```shell\nexport PS1='[\\u@\\h `pwd`]\\$'\t\n```\n\n#### 2、刷新配置文件，使其生效\n\n```shell\n$> source /etc/profile\n```\n\n```shell\n命令释义：\n\\u 显示当前用户账号\n\\h 显示当前主机名\n\\W 只显示当前路径最后一个目录\n\\w 显示当前绝对路径（当前用户目录会以 ~代替）\npwd 显示当前全路径\n\\$ 显示命令行’$'或者’#'符号\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/20190504205919.png)\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n","tags":["Linux"],"categories":["技术分享","Linux"]},{"title":"Java短信微服务开发 SpringBoot + ActiveMQ + 腾讯云SMS","url":"/2019/04/02/Java短信微服务开发 SpringBoot+ActiveMQ+腾讯云SMS/","content":"\n\n\n## 前沿\n\n在去年学习Java的WEB开发时，就慢慢变得上瘾起来，不太愿意用视频中给的静态网页来做项目。自己便用不太熟练的JS写了个注册网页，然后还用上了邮箱验证码，很喜欢这个网页。但是后来的项目一直用不上，直到最近做一个网站，刚好可以用到之前做的注册网页。就把它用更高级的Angular JS改造了一下，并改成了手机短信验证码，感觉更有成就感了！\n\n此次开发的短信微服务是利用SpringBoot快速搭建ActiveMQ，因为我的云服务器和域名都在腾讯云，而且腾讯云短信每个月送100条短信，对我日常开发测试而言，根本用不完，所以使用腾讯云短信API完成发送短信，里面有好多技术都是第一次接触，所以写一下记录下细节。\n\n## 项目架构\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/架构.png)\n\n## 利用SpringBoot搭建ActiveMQ\n\n#### 1、创建Maven工程 letttgaco_sms_service（注意：打包方式为jar）\n\n添加如下依赖至pom.xml\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>cn.letttgaco.sms</groupId>\n\t<artifactId>letttgaco_sms_service</artifactId>\n\t<version>1.0</version>\n    <!-- 用Eclipse建SpringBoot项目会默认为jdk1.6 这里调整为jdk1.7 -->\n\t<properties>\n\t\t<java.version>1.7</java.version>\n\t</properties>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>1.4.0.RELEASE</version>\n\t</parent>\n\t<dependencies>\n        <!-- 起步依赖 SpringBoot核心部分就是依赖传递，它会自动引入WEB开发所需要的所有包，\n\t\t\t甚至连tomcat都内置了，所以这也是它搭建如此之快的原因了-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<!-- activtemq 只需要引入这一个依赖，它就会把所有用到的关联jar包都依赖传递过来-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-activemq</artifactId>\n\t\t</dependency>\n\t\t<!-- 腾讯云短信API -->\n\t\t<dependency>\n\t\t\t<groupId>com.github.qcloudsms</groupId>\n\t\t\t<artifactId>qcloudsms</artifactId>\n\t\t\t<version>1.0.6</version>\n\t\t</dependency>\n        <!-- springboot热部署 除了改pom文件，其他文件改了都不用重启，简直节省大量时间啊-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-devtools</artifactId>\n\t\t</dependency>\n\t</dependencies>\n</project>\n```\n\n#### 2、创建引导类Application.java\n\n这个类是程序的入口，启动它就能启动SpringBoot容器\n\n```java\npackage cn.letttgaco.sms;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n//@SpringBootApplication其实就是以下三个注解的总和\n//@Configuration： 用于定义一个配置类\n//@EnableAutoConfiguration ：Spring Boot会自动根据你jar包的依赖来自动配置项目。\n//@ComponentScan： 告诉Spring 哪个packages 的用注解标识的类 会被spring自动扫描并且装入bean容器。\npublic class Application {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n}\n```\n\n#### 3、使用腾讯云SMS需要准备的信息\n\n在腾讯云开通短信服务，申请好短信签名和短信模板后，可以将相关配置储存到配置文件application.properties（直接在resources中创建）中。[点击前往腾讯云短信官方文档](https://cloud.tencent.com/document/product/382/18071)\n\n```java\n\t// 短信应用SDK AppID\n\tint appid = 1400xxxx; // 1400开头\n\n    // 短信应用SDK AppKey\n    String appkey = \"qwertyuiopasdfghjkl123456789\";\n\n    // 需要发送短信的手机号码\n    String[] phoneNumbers = {\"21212313123\", \"12345678902\", \"12345678903\"};\n\n    // 短信模板ID，需要在短信应用中申请\n    int templateId = 7839; // NOTE: 这里的模板ID`7839`只是一个示例，真实的模板ID需要在短信控制台中申请\n    // 签名\n    String smsSign = \"腾讯云\"; // NOTE: 签名参数使用的是`签名内容`，而不是`签名ID`。这里的签名\"腾讯云\"只是一个示例，真实的签名需要在短信控制台申请。\n```\n\n\n\n#### 4、创建腾讯云SMS工具类SmsUtil.java\n\n```java\npackage cn.letttgaco.sms;\n\nimport java.io.IOException;\nimport java.util.Map;\n\nimport org.json.JSONException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.env.Environment;\nimport org.springframework.stereotype.Component;\n\nimport com.github.qcloudsms.SmsMultiSender;\nimport com.github.qcloudsms.SmsMultiSenderResult;\nimport com.github.qcloudsms.httpclient.HTTPException;\n@Component\npublic class SmsUtil {\n\t//用来读取springboot的配置文件中的内容\n\t@Autowired\n\tprivate Environment env;\n    \n\t/**\n\t * 我只在配置文件中存储了appid和appkey,其他信息我选择从上层传过来\n\t * @param map\n\t */\n\tpublic void sendSms(Map<String,String> map) {\n\t\ttry {\n\t\t\t//因为我这里只会用到单个手机号，所以用map传输\n\t\t\tString phone = map.get(\"phone\");\n\t\t\tint templateId = Integer.parseInt(map.get(\"templateId\"));\n\t\t\tString smsSign = map.get(\"smsSign\");\n            //多个手机号可以在数组中填写多个\n\t\t\tString[] phoneNumbers = {phone};\n\t\t\tString code = map.get(\"code\");\n            //我的短信模板是“欢迎注册，{1}为您的验证码,请于5分钟内填写。”\n            //{1}对应下面数组中的第一个信息\n\t\t\tString[] params = { code };// 对应模板中的内容\n\t\t\t//从配置文件中获取信息\n\t\t\tint appid = Integer.parseInt(env.getProperty(\"appid\"));\n\t\t\tString appkey = env.getProperty(\"appkey\");\n\t\t\tSmsMultiSender msender = new SmsMultiSender(appid,appkey);\n\t\t\t// 签名参数未提供或者为空时，会使用默认签名发送短信\n\t\t\tSmsMultiSenderResult result = msender.sendWithParam(\"86\", phoneNumbers,templateId, params, smsSign, \"\", \"\");\n\t\t\tSystem.out.println(result);\n\t\t} catch (HTTPException e) {\n\t\t\t// HTTP响应码错误\n\t\t\te.printStackTrace();\n\t\t} catch (JSONException e) {\n\t\t\t// json解析错误\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// 网络IO错误\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n\n```\n\n#### 5、创建消息的消费者SmsListener.java\n\n利用SpringBoot甚至不用配置ActiveMQ的xml文件！！！！\n\n```java\npackage cn.letttgaco.sms;\n\nimport java.util.Map;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jms.annotation.JmsListener;\nimport org.springframework.stereotype.Component;\n/**\n * 消息的消费端,监听消息\n * @author LetTTGACO\n *\n */\n@Component\npublic class SmsListener {\n\t\n\t@Autowired\n\tprivate SmsUtil smsUtil;\n\t//destination=\"sendSms\"指消费端会监听名称为sendSms的队列\n\t@JmsListener(destination=\"sendSms\")\n\tpublic void sendSms(Map<String,String> map) {\n\t\tsmsUtil.sendSms(map);\n\t}\n\n}\n\n```\n\n#### 6、创建消息的生产者\n\n```java\npackage cn.letttgaco.user.service.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.jms.core.JmsMessagingTemplate;\n\nimport com.alibaba.dubbo.config.annotation.Service;\n\n\n/**\n * 消息的生产者\n * @author LetTTGACO\n *\n */\n@RestController\npublic class UserServiceImpl implements UserService {\n\t\n    @Autowired\n\tprivate JmsMessagingTemplate jmsMessagingTemplate;\n    \n\t@Value(\"${templateId}\")\n\tprivate String templateId;\n\t\n\t@Value(\"${smsSign}\")\n\tprivate String smsSign;\n\t\n\t@RequestMapping(\"/sendSms\")\n\tpublic void sendSms(String phone) {\n\t\t//将短信内容发送给ActiveMQ\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tmap.put(\"phone\", phone);//手机号\n\t\tmap.put(\"templateId\", templateId);//签名模板\n\t\tmap.put(\"smsSign\", smsSign);//签名内容\n\t\tjmsMessagingTemplate.convertAndSend(\"sendSms\",phone);\n\t\t\n\t}\n\t\n}\n\n```\n\n## 测试\n\n> 注：可以在application.properties设置内置tomcat的访问端口号，默认为8080。\n\n```xml\nserver.port=9080\n```\n\n1、启动Application.java\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/springboot启动.png)\n\n2、打开浏览器\n\n输入`http://localhost:9080/sendSms?phone=13333333333` \n\n消息产生过程：\n\n（1）浏览器访问到控制层sendSms()方法产生消息，并推送给ActiveMQ。\n\n（2）消费者监听消息，接收ActiveMQ的消息，执行发送短信的任务。\n\n（3）手机收到短信\n\n------\n\n至此，短信微服务搭建成功！\n\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["短信"],"categories":["技术分享","后端"]},{"title":"在腾讯云服务器上安装FastDFS","url":"/2019/02/21/在腾讯云服务器上安装FastDFS/","content":"\n## 引言\n\nFastDFS 是一个由 C 语言实现的开源轻量级分布式文件系统，作者余庆[@YuQing](https://github.com/happyfish100)，支持 Linux、FreeBSD、AID 等 Unix 系统，解决了大数据存储和读写负载均衡等问题，适合存储 4KB~500MB 之间的小文件，如图片网站、短视频网站、文档、app 下载站等，UC、京东、支付宝、迅雷、酷狗等都有使用。\n\n## 安装前准备\n\n我的云服务器为腾讯云服务器，系统为CentOS7.2(64位)，自带50G系统盘。\n\n## 安装FastDFS\n\n### 1、上传安装包\n\n此次用到的安装包如图所示，我们首先用FTP工具把FastDFS([点击下载安装包](https://files.letttgaco.cn/技术支持/FastDFS/))的相关安装包上传至服务器的`/usr/local/fastDFS`目录中（也可以自行选择目录，后面在涉及到修改配置文件时会进一步提示说明）。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/FastDFS安装包.png)\n\n### 2、安装基本环境\n\n```shell\nyum -y install libevent\n```\n\n### 3、安装libfastcommonV1.0.7工具包\n\n```shell\ntar -zxvf libfastcommonV1.0.7.tar.gz\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/lib1.png)\n\n进入解压后的目录，看到有`make.sh`，依次执行命令进行编译。\n\n```shell\n./make.sh\n./make.sh install\n```\n### 4、安装Tracker服务\n\n```shell\ntar -zxvf FastDFS_v5.05.tar.gz\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/trackerd.png)\n\n进入文件夹后依次执行命令进行编译:\n\n```\n./make.sh\n./make.sh install\n```\n\n安装后文件会默认安装在 `/usr/bin` 中:\n\n```shell\nll fdfs*\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/usrbin.png)\n\n配置文件在 `/etc/fdfs`目录中：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/etcfdfs.png)\n\n进入`/usr/locla/fastDFS/FastDFS/conf/`目录下:\n\n```shell\ncd /usr/locla/fastDFS/FastDFS/conf/\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/conf.png)\n\n将其所有文件拷贝至`/etc/fdfs`目录下:\n\n```shell\ncp * /etc/fdfs/\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/cpconf.png)\n\n配置tracker服务,进入`/etc/fdfs/`目录下，修改`tracker.conf`文件\n\n```\ncd /etc/fdfs/\nvim tracker.conf\n```\n\n修改`base_path`为自定义存放tracker日志的目录，这里以`/usr/local/fastDFS/trackerLog`为例，如果没有创建此目录，可以先修改再创建。\n\n```shell\nmkdir -p /usr/local/fastDFS/trackerLog\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/basepath.png)\n\n> 这里我们也可以挂载的一个云硬盘，使用云硬盘的目录来存放文件。因为系统盘不支持扩容，以后系统盘满了之后就很麻烦，所以最好就挂载一个硬盘，同时也可以把图片文件都和系统盘给区分开来。我暂时没有云硬盘，这里以系统盘为例。\n>\n\n启动tracker服务并查看进程是否已启动\n\n```shell\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf\n```\n\n```\nps aux|grep trackerd\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/tracker.png)\n\n### 5、安装storage服务\n\n进入`/etc/fdfs/`目录，修改`storage.conf`文件\n\n```shell\nvim /etc/fdfs/storage.conf\n```\n\n修改日志的存储路径，如果没有相关文件夹，可以先配置再创建：\n\n```shell\nmkdir -p /usr/local/fastDFS/storageLog/\n```\n\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/storage1.png)\n\n修改文件的存储路径：\n\n```shell\nmkdir -p /usr/local/fastDFS/storage/\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/path0.png)\n\n\n\n修改`tracker_server` 的值为云服务器的公网IP地址。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/tracker_server1.png)\n\n启动storage服务并且查看进程：\n\n```shell\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf\n```\n\n```shell\nps aux|grep storage\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/startstorage.png)\n\n至此，FastDFS安装完毕，但是我们需要通过http来进行上传文件并访问，所以需要使用nginx一起来搞事情！\n\n### 6、安装nginx\n\n进入`/usr/local/fastDFS`目录，解压缩fastdfs-nginx-module_v1.16.tar.gz\n\n```shell\ntar -zxvf fastdfs-nginx-module_v1.16.tar.gz\n```\n\n修改`/fastdfs-nginx-module/src/config`文件，把其中的`local`去掉:\n\n```shell\ncd fastdfs-nginx-module/src/\n```\n\n```shell\nvim config\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/nginxfastdfs.png)\n\n创建默认的nginx的安装目录：\n\n```shell\nmkdir /usr/local/nginx/\n```\n\n进入nginx根目录进行配置：\n\n```shell\ncd /usr/local/fastDFS/nginx-1.14.2/\n```\n\n直接输入以下命令对nginx进行配置:\n\n> **注意：最后一行`--add-module=/usr/local/fastDFS/nginx/fastdfs-nginx-module/src`的目录为你所指定的`fastdfs-nginx-module`的安装目录**\n\n```shell\n./configure \\\n--prefix=/usr/local/nginx \\\n--pid-path=/var/run/nginx/nginx.pid \\\n--lock-path=/var/lock/nginx.lock \\\n--error-log-path=/var/log/nginx/error.log \\\n--http-log-path=/var/log/nginx/access.log \\\n--with-http_gzip_static_module \\\n--http-client-body-temp-path=/var/temp/nginx/client \\\n--http-proxy-temp-path=/var/temp/nginx/proxy \\\n--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\\n--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\\n--http-scgi-temp-path=/var/temp/nginx/scgi \\\n--add-module=/usr/local/fastDFS/nginx/fastdfs-nginx-module/src\n```\n\n依次执行以下命令进行编译：\n\n```shell\nmake\nmake install\n```\n\n把`/fastdfs-nginx-module/src/mod_fastdfs.conf`文件复制到`/etc/fdfs`目录下：\n\n```shell\ncd /usr/local/fastDFS/nginx/fastdfs-nginx-module/src/\n```\n\n```shell\ncp mod_fastdfs.conf /etc/fdfs\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/modconf.png)\n\n进入`/etc/fdfs/`，打开`mod_fastdfs.conf`并且修改日志存放路径：\n\n```shell\nmkdir -p /usr/local/fastDFS/tmp/\n```\n\n```shell\ncd /etc/fdfs/\n```\n\n```shell\nvim mod_fastdfs.conf\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/basepath1.png)\n\n修改`tracker_server` 的值为云服务器的公网IP地址。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/tracker_server2.png)\n\n修改`storage_path0`的存放路径：\n\n```shell\nmkdir -p /usr/local/fastDFS/storage/\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/storage_path0.png)\n\n进入ngxin的配置文件目录并且修改`nginx.conf`文件：\n\n```shell\ncd /usr/local/nginx/conf/\n```\n\n```shell\nvim nginx.conf\n```\n\n修改原server中的配置为以下：\n\n```xml\nserver {\n        listen       80;\n        server_name  你的公网IP地址;\n\n        location /group1/M00 {\n            ngx_fastdfs_module;\n        }\n}\n```\n\n启动nginx\n\n```shell\n/usr/local/nginx/sbin/nginx \n```\n\n## 安装完成\n\n至此，FastDFS已全部安装完成，下面将介绍如何利用java开发工具来测试FastDFS的上传文件功能。\n\n## 上传测试\n\n需求：将本地图片上传至图片服务器，再控制台打印url。\n\n### 1、创建Maven工程FastDFSTest\n\n由于FastDFS客户端jar包并没有在中央仓库中，所以需要使用下列命令手动安装jar包到Maven本地仓库。\n\n源码地址：[fastdfs-client-java](https://github.com/happyfish100/fastdfs-client-java)，解压后导入Eclipse的Maven工程，右键项目选择`Run As — Maven Install`进行本地仓库的安装。\n\n在你的`FastDFSTest`工程的`pom.xml`中添加依赖：\n\n```xml\n<dependency>\n    <groupId>org.csource</groupId>\n    <artifactId>fastdfs-client-java</artifactId>\n    <version>1.27-SNAPSHOT</version>\n</dependency>\n```\n\n### 2、在resources文件夹中创建`fdfs_client.conf`文件\n\n```shell\n# 连接超时时间\n# 默认30s\n\nconnect_timeout=30\n\n\n# 网络超时时间\n\n# 默认30秒30s\n\nnetwork_timeout=60\n\n\n# 工作文件夹，日志存在此（目录自定）\n\nbase_path=/home/yuqing/fastdfs\n\n# tracer server服务器地址列表，多个tracer server的话，分行列出\n\ntracker_server=你的公网IP:22122\n\n\n#日志级别\n\n### emerg for emergency\n\n### alert\n\n### crit for critical\n\n### error\n\n### warn for warning\n\n### notice\n\n### info\n\n### debug\n\nlog_level=info\n\n\n# 是否使用连接池\n\nuse_connection_pool = false\n\n\n# 连接闲置超时时间，连接如果闲置的时间超过本配置，则关闭次连接，单位秒\n\nconnection_pool_max_idle_time = 3600\n\n\n# 是否从tracer server读取fastdfs的参数，默认为false\n\nload_fdfs_parameters_from_tracker=false\n\n\n# 是否使用storage id 替换 ip，默认为false\n\n# 和tracker.conf该参数含义一样\n\n# 本配置只有在load_fdfs_parameters_from_tracker＝false时生效\n\n# 本配置默认为false\n\nuse_storage_id = false\n\n\n# 指定storage id的文件名，允许使用绝对路径\n\n# 和tracker.conf该参数含义一样\n\n# 本配置只有在load_fdfs_parameters_from_tracker＝false时生效\n\nstorage_ids_filename = storage_ids.conf\n \n\n#HTTP settings\n\nhttp.tracker_server_port=8080\n \n\n#引入HTTP相关配置\n\n##include http.conf\n```\n\n### 3、创建测试java类\n\n```java\npackage cn.letttgaco.fastdfs;\n\nimport org.csource.fastdfs.ClientGlobal;\nimport org.csource.fastdfs.StorageClient;\nimport org.csource.fastdfs.StorageServer;\nimport org.csource.fastdfs.TrackerClient;\nimport org.csource.fastdfs.TrackerServer;\n\npublic class TestDemo {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 1、加载配置文件（绝对路径），配置文件中的内容就是 tracker 服务的地址。\n\t\tClientGlobal.init(\"D:/Codes/Eclipse/Tiramisu/spring-security-demo/src/main/resources/fdfs_client.conf\");\n\t\t// 2、创建一个 TrackerClient 对象。直接 new 一个。\n\t\tTrackerClient trackerClient = new TrackerClient();\n\t\t// 3、使用 TrackerClient 对象创建连接，获得一个 TrackerServer 对象。\n\t\tTrackerServer trackerServer = trackerClient.getConnection();\n\t\t// 4、创建一个 StorageServer 的引用，值为 null\n\t\tStorageServer storageServer = null;\n\t\t// 5、创建一个 StorageClient 对象，需要两个参数 TrackerServer 对象、StorageServer 的引用\n\t\tStorageClient storageClient = new StorageClient(trackerServer, storageServer);\n\t\t// 6、使用 StorageClient 对象上传图片（绝对路径）。\n\t\t// 扩展名不带“.”\n\t\tString[] strings = storageClient.upload_file(\"D:/Codes/TestCodes/c.JPG\", \"jpg\", null);\n\t\t// 7、返回数组。包含组名和图片的路径。\n\t\tfor (String string : strings) {\n\t\t\tSystem.out.println(string);\n\t\t}\n\t}\n\n}\n```\n\n控制台输出如下结果：\n\n```java\ngroup1\nM00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg\n```\n\n### 4、打开浏览器查看已上传的图片\n\n```shell\nhttp://你的公网IP/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg\n```\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["FastDFS"],"categories":["技术分享"]},{"title":"Spring Security安全框架入门","url":"/2019/02/17/Spring Security安全框架入门/","content":"\n## 前沿\n\nSpring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IOC（Inversion of Control控制反转），DI（Dependency Injection 依赖注入）和AOP（Aspect Oriented Programming面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。\n\n### 1、pom.xml\n\n在spring framework常规依赖的基础上添加以下依赖：\n\n```xml\n<dependency>\n\t<groupId>org.springframework.security</groupId>\n\t<artifactId>spring-security-config</artifactId>\n\t<version>4.1.0.RELEASE</version>\n</dependency>\n<dependency>\n\t<groupId>javax.servlet</groupId>\n\t<artifactId>servlet-api</artifactId>\n\t<version>2.5</version>\n\t<scope>provided</scope>\n</dependency>\n```\n\n### 2、web.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns=\"http://java.sun.com/xml/ns/javaee\"\n\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n                        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n         version=\"2.5\">\n    <!-- security安全框架 -->\n\t<context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:spring-security.xml</param-value>\n\t</context-param>\n\t<listener>\n        <listener-class>\n            org.springframework.web.context.ContextLoaderListener\n        </listener-class>\n\t</listener>\t\n\t<filter>  \n        <filter-name>springSecurityFilterChain</filter-name>\n        <filter-class>\n            org.springframework.web.filter.DelegatingFilterProxy\n        </filter-class>\n\t</filter>  \n\t<filter-mapping>  \n        <filter-name>springSecurityFilterChain</filter-name>  \n        <url-pattern>/*</url-pattern>  \n\t</filter-mapping>\t\n</web-app>\n```\n\n### 3、spring-security.xml(静态设置账号密码)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd\">\n\n    <!-- 以下页面不被拦截 -->\n\t<http pattern=\"/login.html\" security=\"none\"></http>\n\t<!-- 页面拦截规则 -->\n\t<http use-expressions=\"false\">\n        <!-- intercept-url表示需要拦截的 -->\n        <!-- /**表示拦截所有,access中必须以\"ROLE_\"开头,后面的是自定的用户-->\n\t\t<intercept-url pattern=\"/**\" access=\"ROLE_TEST\" />\n        <!-- \n\t\t\tlogin-page：指定登录页面。\n\t\t\tauthentication-failure-url：指定了身份验证失败时跳转到的页面。\n\t\t\tdefault-target-url：指定了成功进行身份验证和授权后默认呈现给用户的页面。\n \t\t-->\n        <form-login login-page=\"/login.html\" default-target-url=\"/index.html\" authentication-failure-url=\"/error.html\"/>\n        <!-- 关闭CSRF,如果不加会出现错误 -->\n        <!-- CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。-->\n\t\t<csrf disabled=\"true\"/>\n        <!-- 如果你在系统中使用了框架页，需要设置框架页的策略为SAMEORIGIN -->\n        <headers>\n\t\t\t<frame-options policy=\"SAMEORIGIN\"/>\n\t\t</headers>\n\t</http>\n\n\t<!-- 认证管理器 -->\n\t<authentication-manager>\n\t\t<authentication-provider>\n\t\t\t<user-service>\n                <!-- 为方便测试,将账号密码固定了 -->\n\t\t\t\t<user name=\"admin\" password=\"123456\" authorities=\"ROLE_TEST\"/>\n\t\t\t</user-service>\t\t\n\t\t</authentication-provider>\t\n\t</authentication-manager>\n</beans:beans>\n```\n\n### 4、动态从数据库中获取账号密码\n\n#### （1）创建UserDetailsServiceImpl.java并实现UserDetailsService接口\n\n```java\npackage cn.letttgaco.service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\n\nimport cn.letttgaco.pojo.LoginUser;\n\npublic class UserDetailServiceImpl implements UserDetailsService {\n\n\tprivate SellerService sellerService;\n\n\tpublic void setSellerService(SellerService sellerService) {\n\t\tthis.sellerService = sellerService;\n\t}\n\n\tpublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\tSystem.out.println(\"通过UserDetailServiceImpl\");\n\t\t// 构建角色列表\n\t\tList<GrantedAuthority> grantAuths = new ArrayList<GrantedAuthority>();\n\t\t// 添加角色\n\t\tgrantAuths.add(new SimpleGrantedAuthority(\"ROLE_SELLER\"));\n\t\t//得到用户对象\t\t\n\t\tLoginUser user = userService.login(username);\n\t\tif (user != null) {\n\t\t\t// 返回具有一定角色对象的用户对象\n\t\t\treturn new User(username, user.getPassword(), grantAuths);\n\t\t\treturn null;\n\t\t}else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n```\n\n#### (2)spring-security.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\n\txmlns:beans=\"http://www.springframework.org/schema/beans\" \n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/security \n\thttp://www.springframework.org/schema/security/spring-security.xsd\n\thttp://code.alibabatech.com/schema/dubbo \n\thttp://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n\n\t<!-- 设置不登录也可以访问的页面 -->\n\t<http pattern=\"/*.html\" security=\"none\"></http>\n\t<http pattern=\"/css/**\" security=\"none\"></http>\n\t<http pattern=\"/img/**\" security=\"none\"></http>\n\t<http pattern=\"/js/**\" security=\"none\"></http>\n\t<!-- 放开用户注册入口 -->\n\t<http pattern=\"/user/register.do\" security=\"none\"></http>\n\n\t<!-- 页面拦截规则 use-expressions:是否启用SPEL表达式,默认为true -->\n\t<http use-expressions=\"false\">\n\t\t<!-- 当前用户必须有ROLE_USER的角色才可访问根目录及所属子目录的资源 -->\n\t\t<intercept-url pattern=\"/**\" access=\"ROLE_SELLER\" />\n\t\t<!-- 开启表单登录功能 -->\n\t\t<form-login login-page=\"/login.html\"\n\t\t\tdefault-target-url=\"/index.html\" authentication-failure-url=\"/login.html\"\n\t\t\talways-use-default-target=\"true\" />\n\t\t<!-- 关闭csrf -->\n\t\t<csrf disabled=\"true\" />\n\t\t<!-- 配置策略,使用框架页面 -->\n\t\t<headers>\n\t\t\t<frame-options policy=\"SAMEORIGIN\" />\n\t\t</headers>\n\t\t<logout />\n\t</http>\n\n\t<!-- 添加认证类 -->\n\t<beans:bean id=\"userDetailService\" class=\"cn.letttgaco.service.UserDetailServiceImpl\">\n\t\t<beans:property name=\"userService\" ref=\"userService\"></beans:property>\n\t</beans:bean>\n\n\t<!-- 认证管理器 -->\n\t<authentication-manager>\n\t\t<!-- 认证的提供者 -->\n\t\t<authentication-provider user-service-ref=\"userDetailService\"/>\n\t</authentication-manager>\n</beans:beans>\n```\n\n通过以上配置，用户在登陆页输入用户名和密码与数据库一致即可登陆。\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["Spring Security"],"categories":["技术分享","后端"]},{"title":"注解式配置dubbo服务","url":"/2019/02/09/注解式配置dubbo服务/","content":"\n## 前沿\n\n之前在做项目时一直用的都是dubbo的xml配置，在调试时未防止连接超时，一般会在xml中设置超时时间，但是最近的项目试了下dubbo的注解配置，但是一时半会没找到利用注解配置来设置超时时间，于是找了找资料，整理出常用的dubbo的配置文件以及注解配置设置超时时间等属性。\n\n## 服务提供者\n\n### 1.applicationContext-service.xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://code.alibabatech.com/schema/dubbo\n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n        \n\t<!--发布dubbo服务 -->\n\t<!--提供方应用信息,用于计算依赖关系-->\n\t<dubbo:application name=\"tiramisu-sellergoods-service\" />\n\t<!--注册中心的地址-->\n\t<dubbo:registry protocol=\"zookeeper\" address=\"xxx.xxx.xxx.xxx:2181\" />\n\t<!--用于dubbo协议在20881端口暴露服务-->\n\t<dubbo:protocol name=\"dubbo\" port=\"20881\"/>\n    <!--配置dubbo注解扫描包路径-->\n\t<dubbo:annotation package=\"cn.tiramisu.sellergoods.service.impl\"/>\n</beans>\n```\n\n### 2.@Service实现类\n\n```java\nimport com.alibaba.dubbo.config.annotation.Service;\n\n//注意不是springframework的service\n@Service\npublic class TiramisuServiceImpl implements TiramisuService {\n    \n}\n```\n\n## 服务消费者\n\n### 1.springmvc.xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://code.alibabatech.com/schema/dubbo \n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n\n\t<!-- 引用dubbo服务 -->\n\t<dubbo:application name=\"tiramisu-manager-web\" />\n    <!--注册中心的地址-->\n\t<dubbo:registry address=\"zookeeper://xxx.xxx.xxx.xxx:2181\"/>\n    <!--配置dubbo注解扫描包路径-->\n\t<dubbo:annotation package=\"cn.letttgaco.manager.controller\" />  \t\n</beans>\n```\n\n### 2.@Reference注解\n\n```\nimport com.alibaba.dubbo.config.annotation.Reference;@RestController\n\n@Controller\npublic class BrandController {\n    //使用dubbo提供的reference注解，引用dubbo服务\n\t@Reference\n\tprivate TiramisuService tiramisuService; \n}\n```\n\n## @Service和@Reference的属性配置\n\n------\n\n#### 超时时间的设定\n\n在平时测试过程中，由于dubbo默认的超时时间为5000毫秒，无法很方便的进行测试，容易报超时异常，而在以前的xml配置dubbo时，经常这样配置客户端的超时时间：\n\n```xml\n<!--设置超时时间为30秒-->\n<dubbo:service interface=\"cn.letttgaco.order.service.OrderService\" ref=\"orderServiceImpl\" timeout=\"300000\"/>\n```\n\n但是现在用的是dubbo的注解形式，设置注解形式的超时时间是直接在注解中声明的：\n\n```java\n//都要设置超时时间为30秒\n//服务提供方\n@Service(timeout=300000)\n//服务消费者\n@Reference(timeout=300000)\n```\n\n当然还有更多的属性都可以设置，如果有需要的可以研究下。\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["dubbo"],"categories":["技术分享","后端"]},{"title":"Mybatis分页插件警告解决办法","url":"/2019/02/08/Mybatis分页插件警告解决办法/","content":"\n在使用springmvc+mybatis分页插件pagehelper时，只在业务层引用了mybatis的分页插件的jar包而表现层接收时没有引用，会报这样的警告：\n\n```java\n警告: Hessian/Burlap: 'com.github.pagehelper.Page' is an unknown class in WebappClassLoader\ncontext:\ndelegate: false\nrepositories:\n----------> Parent Classloader:\nClassRealm[plugin>org.apache.tomcat.maven:tomcat7-maven-plugin:2.2\njava.lang.ClassNotFoundException: com.github.pagehelper.Page\n```\n\n解决办法：mybatis的分页pagehelper插件依赖于mybatis的相关jar包，因此解决办法是在表现层同时加入分页pagehelper的jar包和mybatis的相关jar包，如下:\n\n```xml\n<dependency>\n\t<groupId>org.mybatis</groupId>\n\t<artifactId>mybatis</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org.mybatis</groupId>\n\t<artifactId>mybatis-spring</artifactId>\n</dependency>\n<dependency>\n\t<groupId>com.github.miemiedev</groupId>\n\t<artifactId>mybatis-paginator</artifactId>\n</dependency>\n<dependency>\n\t<groupId>com.github.pagehelper</groupId>\n\t<artifactId>pagehelper</artifactId>\n</dependency>\n```\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["Mybatis"],"categories":["BUG记录"]}]