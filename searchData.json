[{"title":"谈一谈二进制","url":"/2020/04/17/谈一谈二进制/","content":"\n# 谈一谈二进制\n\n## 1.二进制与十进制之间的转换\n\n### 1.1十进制转换成二进制\n\n#### (1)整数十进制  => 二进制\n\n##### 取余法\n\n```java\npublic void test1() {\n  String numstr = \"\";\n  int de = 31;\n  while (de > 0) {\n    int res = de % 2; //除2 取余数作为二进制数\n    numstr = res + numstr;\n    de = de / 2;\n  }\n  System.out.println(numstr); //11111\n}\n```\n\n> 十进制整数转换为二进制整数采用\"除2取余，逆序排列\"法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。\n\n原理:假设十进制整数A化得的二进制数为`abcde`的形式，那么用上面的方法按权展开， 得\n\n`A=a(2^4)+b(2^3)+c(2^2)+d(2^1)+e(2^0)` （后面的和不正是化十进制的过程吗）\n\n假设该数未转化为二进制,除以基数`2`得\n\n`A/2=a(2^4)/2+b(3^1)/2+c(2^2)/2+d(1^3)/2+e(2^0)/2`\n\n注意：`e`除不开二，余下了！其他的绝对能除开，因为他们都包含`2`，而`e`乘的是`1`，他本身绝对不包含因数`2`，只能余下。所以可以得到余数`e`，`A/2 - e/2` 得到新的整数`a(2^3)+b(2^2)+c(2^1)+d(2^0)`，然后 再除以基数`2`余下了`d`，以此类推。当这个数不能再被`2`除时，先余掉的`e`位数在原数低，而后来的余数数位高，所以要把所有的余数反过来写。正好是`abcde`\n\n##### 移位异或法\n\n```java\npublic void test2() {\n  int num = 31;\n  //定义一个String用于返回得到的二进制\n  String binary = \"\";\n  while (num > 0) {\n    //获取每一位\n    int bit = num & 1;\n    //将获取的位添加到字符串\n    binary = bit + binary;\n    //向右移一位\n    num = num >> 1;\n  }\n  System.out.println(binary);\n}\n```\n\n> 这种位运算运用了一个特点：任何二进制数与1进行与运算都会得到其最低的低位有效位，即二进制数的最后一个数本身。所以让这个正整数与1进行与运算，再右移一位后把最后一位消除掉（整数/2），再进行如此的循环操作就可以得到这个正整数的每一位二进制数，因为先运算的数位低，后运算的高，所以进行一个反向排列就可以得到该正整数对应的二进制数。\n\n\n\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["数据结构"],"categories":["填坑之路"]},{"title":"图片优化的那些事","url":"/2020/04/17/从图片优化说起/","content":"\n# 图片优化的那些事\n\n图片是大部分网页的重要组成部分，一般情况下，我们不会太关注这方面的问题，需要显示图片直接一个 `img` 标签搞定。\n\n但实际上，无论是对于提高加载速度，还是对于优化用户体验，优化图片都是一个重要的手段。\n\n图片优化分成两个方面：\n\n第一，图片压缩。在保证视觉效果的情况下，减少图片的体积。这个很有效，1M 和 100K 的图片，肉眼看起来几乎差不多，但却省了 90% 的流量，大大提高了加载速度。\n\n第二，响应式图片。根据客户端的情况，选择最合适的图片返回给用户。用户是一个 500px 的设备，那么返回 1000px 的图给他就是浪费（假设物理像素和 CSS 像素是一比一）。\n\n我们先来看图片压缩。\n\n## 图片压缩\n\n压缩的第一步是筛选出需要压缩的图片。如果图片本身就已经足够小了，那么再压缩的意义就不大。\n\n而对于这些足够小的图片，我们就可以将其转换成雪碧图**（CssSprites）**或者`base64`编码来存储，而关于这两者的使用场景这里可以看一下这两篇文章（[不要滥用雪碧图sprite](https://www.cnblogs.com/joyho/articles/3715275.html)和[玩转图片Base64编码](https://www.cnblogs.com/coco1s/p/4375774.html)）。\n\n### url-loader\n\n这里我采用的是`webpack`里的`url-loader`插件进行处理，对于小于`1kb`的图片，将其转换成`base64`编码进行存储。\n\n```javascript\n{\n  test: /\\.(png|jpe?g|gif|svg)$/,\n  use: [{\n      loader: \"url-loader\", // 它封装了file-loader，所以可以使用两个loader的全部配置属性\n      options: {\n        limit: 1024,\n        esModule: false,\n        outputPath: 'images' // 设置图片的输出路径\n      }\n    }\n  ]\n},\n```\n\n> **参数说明**\n>\n> `limit`是转换成Base64的图片大小的零界点设置单位为Byte，小于该数值的将进行转换。\n>\n> `esModule`是针对是否使用模块化框架的用户设定参数，默认为true。如果项目中没有使用模块化框架，建议要将这个属性关闭，避免出现图片资源超过limit，就变成[object Module]的问题。\n>\n> `outputPath`图片输出路径，将优化后的图片统一输出到该路径。\n\n### image-webpack-loader\n\n接下来就是压缩大一点的图片了，使用[image-webpack-loader](https://github.com/tcoopman/image-webpack-loader)进行进一步处理。\n\n```javascript\n{\n  test: /\\.(png|jpe?g|gif|svg)$/,\n  use: [{\n      loader: \"url-loader\",\n      options: {\n        limit: 1024,\n        esModule: false,\n        outputPath: 'images'\n      }\n    },\n    {\n      loader: 'image-webpack-loader',\n      options: {\n        mozjpeg: {\n          progressive: true,\n          quality: 70 // 数值越高，质量越好\n        },\n        optipng: {\n          // enabled: false,\n          OptimizationLevel: 4 // 默认是3\n        },\n        pngquant: {\n          enabled：false,\n          // quality: [0.75,0.95],\n          // speed: 4\n        },\n        gifsicle: {\n          interlaced: true, // 默认：false 隔行扫描gif进行渲染\n        },\n        // webp: {\n        //   quality: 75\n        // }\n      }\n    }\n  ]\n},\n```\n> 如文档所说，[image-webpack-loader](https://github.com/tcoopman/image-webpack-loader)随附以下优化器，默认情况下会自动启用这些优化器：\n>\n> - [mozjpeg](https://github.com/imagemin/imagemin-mozjpeg) — 压缩JPEG图像\n> - [optipng](https://github.com/kevva/imagemin-optipng) — 压缩PNG图像\n> - [pngquant](https://github.com/imagemin/imagemin-pngquant) — 压缩PNG图像\n> - [svgo](https://github.com/kevva/imagemin-svgo) — 压缩SVG图像\n> - [gifsicle](https://github.com/kevva/imagemin-gifsicle) — 压缩GIF图像\n>\n> 和可选的优化器：\n>\n> - [webp](https://github.com/imagemin/imagemin-webp) —将JPG和PNG图像压缩为WEBP\n>\n> 可以通过指定禁用默认优化器`optimizer.enabled: false`，并将其放在选项中即可启用可选优化器。\n#### [imagemin-mozjpeg](https://github.com/imagemin/imagemin-mozjpeg)\n\nJPEG 根据显示方式的不同，分为两种：Progressive JPEG 和 Baseline JPEG。Progressive JPEG 会先加载模糊的整张图片，然后变的越来越清晰。而 Baseline JPEG 会先清晰地加载图片的一部分，然后慢慢显示剩余的部分。\n\n从视觉效果来说，Progressive JPEG 自然更好一些。但它也有一些缺点，比如它的解码速度比 Baseline JPEG 要慢，占用的 CPU 时间更多。\n\n如果是桌面浏览器，这点性能问题自然无所谓，但是如果是移动端，就不得不考虑。工程本来就是权衡的艺术。\n\n默认情况下，MozJPEG 生成的是 Progressive JPEG，可以通过 [选项](https://github.com/imagemin/imagemin-mozjpeg#progressive) 调整。\n\n#### [optipng](https://github.com/imagemin/imagemin-optipng)\n\n在研究文档的过程中发现一个有趣的问题，也可能是官网无意中的行为（真的吗？），官方文档为了说明其API中的禁用指定优化器功能`optimizer.enabled: false`，就在文档中写了这么一段代码：\n\n```javascript\n{\t\n// optipng.enabled: false will disable optipng\n\toptipng: {\n\t\tenabled: false,\n\t},\n  pngquant: {\n    quality: [0.65, 0.90],\n    speed: 4\n    }\n}\n```\n\n本来是一个举例说明，结果在我google的几乎所有用户的webpack配置中，大家都把optipng这个优秀的压缩工具给禁用了QAQ。\n\n实际上在压缩质量上来说，`optipng`是无损压缩，采用的是基于LZ/Huffman的DEFLATE算法，以减少图片IDAT chunk区域的数据来实现压缩图片，同样是无损压缩的工具还有**[pngcrush](https://pngcrush.com/)、[pngout](https://www.oschina.net/translate/4-free-tools-to-optimize-and-compress-png-images-without-loosing-quality?print)、advpng**。\n\n而[pngquant](https://github.com/kornelski/pngquant)和**[tinypng](https://tinify.cn/)、[ImageAlpha](https://github.com/kornelski/ImageAlpha)、[pngnq](https://github.com/stuart/pngnq)**等都是有损压缩，采用的是quantization算法，将24位的PNG图片转换为8位的PNG图片，减少图片的颜色数来实现图片压缩；\n\n具体可以参考[Laya 图片压缩](https://www.jianshu.com/p/83d00a7e2a4b)对于各个压缩工具的对比情况。\n\n但是呢，一般有损压缩的压缩率会大大高于无损压缩。就如png和jpg两者来说，png格式可以进行无损压缩，质量好、支持透明但是体积大，jpg的质量相对差一点但是体积很小，两者体积相差几乎在70%以上。所以具体的权衡取舍还是看个人实际应用场景。\n\n#### [pngquant](https://github.com/imagemin/imagemin-pngquant) \n\n正如上面所说，它是一个有损压缩，我这里为了演示，暂时禁用了它。\n\n> **参数说明(引用自[Laya 图片压缩](https://www.jianshu.com/p/83d00a7e2a4b))：**\n>  1.`quality`参数的作用是保证图片经过优化处理后，图片质量的取值范围（0~1）。取值越小，表示压缩比率越大，同时的图片的质量也就越差。在测试过程中发现，当设置最低取值为0.60或0.65时，部分图片的质量会严重下降，因此最终选择了0.70作为最低值。\n>  2.`speed`参数的设置决定了图片优化的执行速度，取值范围为1~10，默认值为4。其中10的执行速度最快，对应的压缩比率最小；而1的执行速度最慢，对应的压缩比率最大。在测试过程中发现，无论我设置哪一个值它们的执行时间都差不多，不过压缩比率确实1的最大，10的最小。\n>  实测效果：\n>  在设置quality的取值范围为0.70~0.95，以及speed为4的情况下，可以在尽可能不影响图片质量的前提下去缩减文件的大小。\n>  在测试过程中，我们以PNG-8品质为256的图片为例，最终的图片输出可以降低70%左右的大小（从3.78KB缩减到1.13KB）。\n\n#### [gifsicle](https://github.com/imagemin/imagemin-gifsicle)\n\n[gifsicle](https://github.com/imagemin/imagemin-gifsicle)一共有4个参数配置，我一般常用的就interlaced，即隔行扫描进行渲染，图片会自上而下渐进式加载。\n\n在上文中提到的Progressive和Baseline的区别中，`progressive `等同于`interlaced`，`baseline` 等同于 `not interlaced`，所以取舍自己决定。\n\n> 参数说明\n>\n> `optimizationLevel`是优化级别，默认值为1，取值范围在1-3。优化级别的高低决定图片的质量，较高的级别需要更长的时间，但可能会有更好的效果。\n>\n> 文档中给出了3种取值所做的事：\n>\n> 1：仅存储每个图像的更改部分。\n>\n> 2：还使用透明度进一步缩小文件。\n>\n> 3：尝试几种优化方法（通常速度较慢，有时效果更好）。\n>\n> `colors`是颜色减少的高低设置，是将每个输出GIF中的不同颜色数量减少到指定数值或者更少，取值范围在2-256之间。\n>\n> `buffer`是利用缓冲进行优化。\n\n#### webp\n\n最后来看一下该插件的可选优化器Webp，参考[将之前的项目图片进行了压缩](https://blog.liuguofeng.com/p/4776)这篇文章。\n\n> [WebP](https://developers.google.com/speed/webp/)是Google推出的一种相对较新的格式，旨在通过编码[无损](https://en.wikipedia.org/wiki/Lossless_compression)和[有损](https://en.wikipedia.org/wiki/Lossy_compression)格式的图像来提供较小的文件大小，使其成为JPEG和PNG的绝佳替代品。\n>\n> WebP图像的视觉质量通常与JPEG和PNG相当，但通常文件大小要小得多。例如，当我将屏幕截图从上面转换为WebP时，我得到了一个88 KB的文件，其质量与913 KB的原始图像相当。**减少90％！**\n>\n> 看一看下面三张图，你能分辨的出来吗？\n>\n> - [原始图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232154.png)\n>\n> - [优化后的图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232255.png)\n>\n> - [webp图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232329.webp)\n>\n> 就个人而言，视觉质量具有可比性，您所获得的节省很难被忽视。现在我们已经确定了尽可能使用WebP格式的价值，但是要注意是它不能完全取代JPEG和PNG。根据[caniuse.com](https://caniuse.com/#search=WebP)提供的数据显示，虽然浏览器中的WebP支持已经很普遍了，但是需要足够高的版本号才可支持。\n>\n> ![浏览器支持](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419233351.png)\n>\n> 截止撰稿日，只有Safari还在试验中，也算是即将支持webp图片了。至于IE浏览器嘛，emmmm一言难尽:slightly_smiling_face:\n>\n> 数据显示，全球有77.63%的用户使用支持WebP的浏览器。这意味着，通过提供WebP图像，您可以为77.63%的客户提高网页速度。\n>\n> 所以，在客户端支持的情况下，我们应该尽可能地使用 WebP 格式。\n\n至于针对webp图片的进一步优化，将在下文中详细介绍。\n\n## 响应式图片\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["图片优化"],"categories":["技术分享"]},{"title":"canal命令总结","url":"/2020/04/13/canal命令总结/","content":"# canal命令总结\n\n### 查看端口：netstat -ntulp\n\n## canal\n\n```\n路径：/root/canal\n配置文件：vim /root/canal/conf/example/instance.properties\n启动：sh /root/canal/bin/startup.sh\n关闭：sh /root/canal/bin/stop.sh\nserver日志：tail -100f logs/canal/canal.log\nnstance日志：tail -100f logs/example/example.log\n删除日志：rm -rf logs/canal/canal.log logs/example/example.log\n端口：119.27.172.40:11111\n```\n\n## zookeeper\n\n```\n路径：/usr/local/zookeeper\n配置文件：vim conf/zoo.cfg\n启动：bin/zkServer.sh start\n关闭：bin/zkServer.sh stop\n状态：zkServer.sh status\n验证：telnet 127.0.0.1 2181\n\t\t stat\n关闭：./zkServer.sh stop\n端口：119.27.172.40:2181\n```\n\n### zkui\n\n```\n路径：/root/zkui\n配置文件：vim config.cfg\n配置文件：vim target/config.cfg\n前台启动：java -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar\n后台启动：nohup java -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar & \n端口：119.27.172.40:9090\n```\n\n## kafka\n\n```\n路径：/usr/local/kafka/kafka_2.11-1.1.1\n配置文件：vim config/server.properties\n启动server：bin/kafka-server-start.sh  -daemon  config/server.properties &\n关闭server：bin/kafka-server-stop.sh\n查看所有topic：bin/kafka-topics.sh --list --zookeeper 119.27.172.40:2181\n查看指定topic下面的数据：\nbin/kafka-console-consumer.sh --bootstrap-server 119.27.172.40:9092  --from-beginning --topic example_t\n端口：119.27.172.40:9092\n```\n\n"},{"title":"Tinymce-Vue初体验","url":"/2020/03/07/Tinymce-Vue初体验/","content":"\n# Tinymce-Vue初体验\n\n最近有需求需要用到富文本编辑器，而且需要将上传/粘贴的图片上传到阿里云OSS上。在简单体验了几个富文本编辑器之后，决定选用Tinymce。\n\n## Tinymce-Vue\n\nTinymce-Vue里面的坑还是挺多的，花了两天时间终于把一些简单的坑填上了，基本上算是满足了需求。这里来简单讲一下在项目中使用 `Tinymce-Vue` 的经过。\n\n### Tinymce-Vue插件安装\n\n```shell\nnpm install @tinymce/tinymce-vue -D\nnpm install tinymce -D\n```\n\n安装成功之后，在`node_modules`目录中，找到`tinymce`中的`skins`目录，将其拷贝到`static`或者`public`目录下。为了结构清晰，我外层包了`tinymce`目录。\n\n> 踩坑①：用不同版本的`vue-cli`创建出来的项目，默认静态公共资源的目录是不一样的。`vue-cli2`的默认静态公共资源目录为`static`，但是`vue-cli3`默认为`public`。拷贝的时候根据自己项目的配置注意下\n\n由于`tinymce`默认是英文界面，如果需要下载[中文的语言包](https://www.tiny.cloud/get-tiny/language-packages/)，可以去官网下载。下载之后将其放在`public/tinymce/`下。同样的，为了结构清晰，我将其放在了`langs`目录下。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/tinymce1.png)\n\n### 起步\n\n在组件中初始化`Tinymce.vue`组件，并引入需要用到的依赖。\n\n```javascript\n// 引入基本文件\nimport tinymce from 'tinymce/tinymce'\nimport Editor from '@tinymce/tinymce-vue'\n// 引入主题文件\nimport 'tinymce/themes/silver'\n// 引入你需要的插件\nimport 'tinymce/plugins/paste' //粘贴插件，很强大，配置后可以粘贴图片\nimport 'tinymce/plugins/image' //上传图片的插件\nimport 'tinymce/plugins/table' //表格\nimport 'tinymce/plugins/wordcount'\n```\n\n由于`Editor-vue`也是官方封装的组件，所以需要注册组件使用。\n\n```javascript\ncomponents: {\n    Editor\n}\n```\n\n使用组件，代码如下：\n\n```html\n<template>\n  <div class=\"tinymce-editor\">\n    <editor\n      :key=\"tinymceFlag\"\n      class=\"editor\"\n      v-model=\"myValue\"\n      :init=\"tinymceInit\">\n    </editor>\n    <a-button @click=\"handleSubmit\" type=\"primary\" class=\"button\">{{ label }}</a-button>\n  </div>\n</template>\n\n<script>\n// 引入基本文件\n// eslint-disable-next-line no-unused-vars\nimport tinymce from 'tinymce/tinymce'\nimport Editor from '@tinymce/tinymce-vue'\n// 引入主题样式\nimport 'tinymce/themes/silver'\n// 引入你需要的插件\nimport 'tinymce/plugins/paste'\nimport 'tinymce/plugins/image'\nimport 'tinymce/plugins/table'\nimport OSS from '@/utils/oss.js'\nimport v1 from 'uuid'\n\nexport default {\n  name: 'Tinymce',\n  data () {\n    return {\n      tinymceFlag: 1,\n      myValue: '',\n      isShowFileDlg: false,\n      tinymceInit: {}\n    }\n  },\n  props: {\n    // 基本路径，默认为空根目录，如果你的项目发布后的地址为目录形式，\n    // 即abc.com/tinymce，baseUrl需要配置成tinymce，不然发布后资源会找不到\n    // 我也不知道为啥要设置baseUrl，我目前没有遇到这个问题。等遇到再说\n    baseUrl: {\n      type: String,\n      default: ''\n    },\n    // 定义允许上传的图片类型\n    accept: {\n      default: 'image/jpeg, image/png',\n      type: String\n    },\n    // 最大上传图片大小\n    maxSize: {\n      default: 5242880,\n      type: Number\n    },\n    // 偶尔会需要禁用富文本\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    // 设置默认需要的拓展\n    plugins: {\n      type: [String, Array],\n      default: 'image table wordcount'   // 可以按照自己需要配置默认需要的组件\n    },\n   \t// 设置默认菜单栏 ‘|’ 用来分隔功能\n    toolbar: {\n      type: [String, Array],\n      default: 'undo redo | formatselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | image table'\n    },\n    // 自己项目需要做一个类似提交表单的按钮\n    label: {\n      type: String,\n      default: '提交'\n    },\n    // 设置默认宽度\n    width: {\n      type: String,\n      default: '1200'\n    },\n    // 设置默认高度\n    height: {\n      type: String\n    }\n  },\n  components: {\n    Editor\n  },\n  mounted () {\n  },\n  created () {\n    // 定义self防止this调用时指向性问题\n    const self = this\n    self.tinymceInit = {\n      fontsize_formats: '11px 12px 14px 16px 18px 24px 36px 48px 50px 56px 60px 64px',\n      language_url: `/tinymce/langs/zh_CN.js`, // 设置中文语言的路径，我的是/public下的tinymce\n      skin_url: '/tinymce/skins/ui/oxide', // skin路径\n      language: 'zh_CN',\n      width: this.width,\n      browser_spellcheck: true, // 拼写检查\n      branding: false, // 去水印\n      statusbar: false, // 隐藏编辑器底部的状态栏\n      paste_data_images: true, // 允许粘贴图像\n      menubar: false, // 隐藏最上方menu\n      plugins: this.plugins,\n      toolbar: this.toolbar,\n      // 设置图片上传时的上传函数，支持图片复制粘贴前上传到指定服务器然后返回url到富文本\n      images_upload_handler: (blobInfo, success, failure) => {\n        if (blobInfo.blob().size > self.maxSize) {\n          failure('文件体积不能超过' + this.maxSize / (1024 * 1024) + 'Mb')\n        }\n        if (self.accept.indexOf(blobInfo.blob().type) >= 0) {\n          uploadPic()\n        } else {\n          failure('图片格式错误, 仅支持' + this.accept + '格式的图片')\n        }\n        // 异步上传到OSS\n        async function uploadPic () {\n          if (self.client) {\n            //值得注意的是，测试时，微信截图后直接在富文本进行粘贴后会出现OSS文件类型报错，需要传入Buffer流或者Blob文件，可blobInfo.blob()按道理应该是blob才对，可还是报错，无奈做了一个blobInfo.blob()的带的File文件对象 ==》 ArrayBuffer流 ==》 Buffer流 才使得OSS能够识别。\n            const reader = new FileReader()\n            reader.readAsArrayBuffer(blobInfo.blob()) // File文件对象 ==》 ArrayBuffer流\n            reader.onload = function (event) {\n              console.log(event.target.result)\n              // 引入UUID防止文件覆盖\n              const fileName = `${v1()}-${blobInfo.name()}`\n              self.client\n                // ArrayBuffer流 ==》 Buffer流 ==》 OSS.put()\n                .put(fileName, toBuffer(event.target.result))\n                .then(result => {\n                  // 得到OSS返回的url\n                  result.url = result.res.requestUrls[0].split('?')[0]\n                  // 将上传完成的状态抛出\n                  self.$emit('on-upload-complete', result) // 抛出 'on-upload-complete' 钩子\n                  // 返回url\n                  success(result.url)\n                })\n                .catch(err => {\n                  // 失败\n                  failure(err)\n                })\n            }\n          } else {\n            // 封装的OSS的错误提示（ak失效时触发）\n            await self.$message.info('上传配置已失效，重新加载中...')\n          }\n          return {\n            failure () {}\n          }\n          // ArrayBuffer流 ==》 Buffer流\n          function toBuffer (ab) {\n            const buf = Buffer.alloc(ab.byteLength)\n            const view = new Uint8Array(ab)\n            for (let i = 0; i < buf.length; ++i) {\n              buf[i] = view[i]\n            }\n            return buf\n          }\n        }\n      }\n    }\n  },\n  watch: {\n    myValue (newValue) {\n      this.$emit('input', newValue)\n    }\n  },\n  activated () {\n    // 当使用keep-alive时，在切换标签页再切回来会出现富文本key缺少无法使用的情况，在这个里做一个处理，让每次的key不一样\n    this.tinymceFlag++\n  },\n  methods: {\n    // 自己的业务需求需要一个提交按钮，将值传回父组件\n    handleSubmit () {\n      this.$emit('submit', this.myValue)\n    }\n  },\n  computed: {\n    // 封装的OSS的初始化方法\n    client: function () {\n      return OSS.client()\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  .tinymce-editor {\n    margin-left: 30px;\n    .button {\n      margin-top: 15px;\n      float: right;\n    }\n  }\n</style>\n```\n\n> 坑②：当使用`keep-alive`时，富文本会出现`key`重复的问题\n>\n> 坑③：微信截图完直接粘贴图片后`blobInfo.blob()`生成一个不能被`OSS`识别的`File`对象，需要`File`文件对象 ==》 `ArrayBuffer`流 ==》 `Buffer`流 才能被`OSS`识别\n\n\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["Tinymce"],"categories":["技术分享","前端"]},{"title":"Git常用命令","url":"/2020/03/01/Git常用命令/","content":"\n# Git常用命令\n\n记录学习一下每天都在使用的Git操作命令，以加快工作效率、应对意外情况的发生为目标。\n\n![Git常用命令](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/Git常用命令.png)\n\n```\n  - Workspace：工作区\n  - Index / Stage：暂存区\n  - Repository：仓库区（或本地仓库）\n  - Remote：远程仓库\n```\n\n  \n\n## git stash\n`git stash`的应用场景有以下几种情况，我都遇到过，以往我都是把代码复制出来再改BUG，今天才发现这么做简直很蠢QAQ。\n\n- 发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑`git stash`。\n\n- 使用git的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码`commit`提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用`git stash`就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用`git stash apply`将以前一半的工作应用回来。\n\n- 经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是`git stash`命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。\n\n`git stash`会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。\n比如下面的中间状态，通过git stash命令推送一个新的储藏，当前的工作目录就干净了。而且`git stash`是本地存储，并不会推送到服务器。\n\n```shell\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n$ git stash\nSaved working directory and index state WIP on master: e4f060f add readme\n\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n### 1. git stash save\n\n实际应用中推荐给每个stash加一个message，用于记录版本，使用`git stash save`取代`git stash`命令。\n\n```shell\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n$ git stash save '改了index的标题'\nSaved working directory and index state On master: 改了index的标题\n\n$ git status\nOn branch master\nnothing to commit, working tree clean\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n```\n\n### 2. git stash apply\n\ngit stash apply用于将缓存堆栈中的stash恢复到工作目录中，但并不删除stash拷贝。也可以使用`git stash apply stash@{1}` 指定恢复某个`stash`，不加参数默认最近的一个stash，即`git stash apply stash@{0}`\n\n```shell\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash apply stash@{1}\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n```\n\n### 3. git stash pop\n\n和`apply`作用类似，这个指令可以将缓存堆栈中的第一个`stash`删除，并将对应修改应用到当前的工作目录下。\n\n```shell\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\nstash@{3}: WIP on master: e4f060f add readme\n\n$ git stash pop\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (91bfd4fd55e0e3f90a480dfc5bebe0394a393860)\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n\n\n```\n\n### 4. git stash drop\n\n用于移除缓存堆栈中的第一个`stash`，也可以指定删除某一个`stash`\n\n```shell\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\nstash@{3}: WIP on master: e4f060f add readme\n\n$ git stash drop\nDropped refs/stash@{0} (22b04ba90a37fb36d5f8e7228e7d8cee324a148b)\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash drop stash@{2}\nDropped stash@{2} (33d9570595f16bc5f4a07247551377e10a0a6ce1)\n\n$ git stash  list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\n```\n\n### 5. git stash show\n\n用于查看最近一个或者指定`stash`的diff，貌似用到的不多，记录下。`git stash show -p`可以查看特定`stash`的全部`diff`以及更人性化一点，\n\n```shell\n$ git stash  list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash show\n index.html | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n$ git stash show stash@{2}\n index.html | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n \n$ git stash show -p\ndiff --git a/index.html b/index.html\nindex 79c2914..47be827 100644\n--- a/index.html\n+++ b/index.html\n@@ -5,9 +5,9 @@\n......\n```\n\n### 6. git stash branch\n\n这条命令会根据最近的 `stash` 创建一个新的分支，然后删除最近的 `stash`（和 `stash pop` 一样）。如果你需要某个 `stash`，你可以指明 `stash id`。\n\n```shell\n# git_learning (master)\n$ git stash\nSaved working directory and index state WIP on master: e4f060f add readme\n\n# git_learning (master)\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\n\n# git_learning (master)\n$ git stash branch testbranch\n# 或者指定id \n#$ git stash branch testbranch stash@{0}\nSwitched to a new branch 'testbranch'\nOn branch testbranch\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (e943a81398f2f01a2d64b227488af67a49b78e57)\n\n# git_learning (testbranch)\n$ git stash list\n# 无,被删除了\n```\n\n### 7. 小结\n\n默认情况下，`git stash`会缓存下列文件：\n\n- 添加到暂存区的修改（`staged changes`）\n- Git跟踪的但并未添加到暂存区的修改（`unstaged changes`），即`git add` 但未 `git commit`\n\n但不会缓存一下文件：\n\n- 在工作目录中新的文件（`untracked files`）\n- 被忽略的文件（`ignored files`）\n\n`git stash`命令提供了参数用于缓存上面两种类型的文件。使用`-u`或者`--include-untracked`可以缓存`stash untracked`文件。使用`-a`或者`--all`命令可以stash当前目录下的所有修改。\n\n\n\n## git checkout\n\n### 1. 基础用法\n\n`checkout`最常用的用法莫过于对于工作分支的切换了：\n\n`git checkout branchName`只是将项目切换到任意分支，不创建分支。\n\n除非再`git clone` 一个新的项目后，因为只会默认在本地创建一个`master`分支，这个时候想要切换到远程分支的话，一般是创建该分支的本地分支并切换到该分支。\n\n```\n创建新分支：git branch branchName\n\n切换到新分支：git checkout branchName\n```\n\n但是大多数情况下都是创建分支的时候切换分支。所以以上语句可以合成一句话：\n\n`git checkout -b branchName`\n\n### 2. 进阶\n\n要想更深入的了解`checkout`，我们需要了解`checkout`的作用机制。该命令的主要关联目标其实是`.git` 文件夹下的`HEAD`文件。\n\n我们可以看到`HEAD`头文件是一个引用，指向的是当前的分支，如果变更分支，该`HEAD`会变更。\n\n```shell\n# git_learning (master)\n$ cd .git/\n\n# git_learning/.git (GIT_DIR!)\n$ ls\nCOMMIT_EDITMSG  description  gitk.cache  hooks/  info/  objects/   refs/\nconfig          FETCH_HEAD   HEAD        index   logs/  ORIG_HEAD\n\n# git_learning/.git (GIT_DIR!)\n$ cat HEAD\nref: refs/heads/master\n\n# git_learning/.git (GIT_DIR!)\n$ cd refs/heads/\n\n# git_learning/.git/refs/heads (GIT_DIR!)\n$ ls\n111  master  new_branch  testbranch\n\n# git_learning/.git/refs/heads (GIT_DIR!)\n$  cat master\ne4f060f544371c8adab70af931ba008024bdc2e1\n\n# git_learning (master)\n$ git checkout 111\nSwitched to branch '111'\n\n# git_learning (111)\n$ cat .git/HEAD\nref: refs/heads/111\n```\n\n\n\n.....\n\n持续记录中QAQ\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["Git"],"categories":["技术分享"]},{"title":"HBase集群搭建过程中容易出现的Bug汇总及解决方案","url":"/2019/05/14/HBase集群搭建过程中容易出现的Bug汇总及解决方案/","content":"\n## 前言\n\n最近在搭建Hadoop+zookeeper+HBase集群过程中，HBase老是出现各种问题，经过不断查看日志文件，找各种解决办法......此时此时，我终于是搭建成功了吼吼吼~值得庆祝一下。以下是我在搭建HBase集群过程中出现的问题记录，改天抽空写一下Hadoop+zookeeper+HBase的集群搭建。\n\n### hbase-site.xml\n\n先放一下最后搞定成功的配置文件\n\n```xml\n<!-- 设置HRegionServers共享目录。因为我搭建的是高可用集群，\n\t所以这里的hbase.rootdir值来自hadoop中的hdfs.default的值 -->\n<property>\n\t<name>hbase.rootdir</name>\n\t<value>hdfs://mycluster/hbase</value>\n</property>\n<!-- 启用分布式模式 -->\n<property>\n\t<name>hbase.cluster.distributed</name>\n\t<value>true</value>\n</property>\n<!-- master主机的端口号 -->\n<property>\n\t<name>hbase.master</name>\n\t<value>mycluster:60000</value>\n</property>\n<!-- 指定Zookeeper集群位置 -->\n<property>\n\t<name>hbase.zookeeper.quorum</name>\n\t<value>s201:2181,s202:2181,s203:2181</value>\n</property>\n <!-- 指定独立Zookeeper安装路径 -->\n<property>\n\t<name>hbase.zookeeper.property.dataDir</name>\n\t<value>/home/letttgaco/zookeeper</value>\n</property>\n<!-- 指定ZooKeeper集群端口 -->\n<property>\n\t<name>hbase.zookeeper.property.clientPort</name>\n\t<value>2181</value>\n</property>\n```\n\n### Bug汇总\n\n####  （1）java.net.UnknownHostException: MyCluster\n\n这是因为，HBase没有识别MyCluster这个集群，解决这个问题的方法是把Hadoop的2个配置文件（`core-site.xml`和`hdfs-site.xml`），放到每个HBase的conf目录下，让HBase能找到Hadoop的配置。\n\n#### （2）zookeeper.MetaTableLocator: Failed verification of hbase:meta,,1 at address xxx\n\n如果你也是集群搭建过程中出现这个问题，请清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n#### （3）ERROR: org.apache.hadoop.hbase.ipc.ServerNotRunningYetException: Server is not running yet\n\n如果你也是集群搭建过程中出现这个问题，请清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n#### （4）org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby \n\n这是由于启动hbase时，namenode所在节点的主机的hadoop状态为standby（备用）态，hbase master进程会在启动后自动停掉。我出现这个的原因是：我虽然准备搭建hbase集群，但是在`hbase-site.xml`配置文件中的`hbase.rootdir`属性中配置的依然是单一某个主机节点的共享目录，导致在standby态的主机启动hbase坏掉。所以解决方案是参照我的配置文件进行修改，清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后重新启动`start-hbase.sh`。\n\n#### （5）exception=org.apache.hadoop.hbase.NotServingRegionException: Region hbase:meta,,1 is not online on xxx\n\n即使我已经搭建好的集群，我每次启动还是会报这个错误，但是并不影响正常运行。。。\n\n如果你是集群搭建过程中出现这个问题，请清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n#### （6）org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.fs. PathIsNotEmptyDirectoryException): `/hbase/WALs/xxx-splitting is non empty': Directory is not empty\n\n我出现的原因是配置文件配错，在hbase-site.xml配置文件中的`hbase.rootdir`属性中配置的依然是单一某个主机节点的共享目录，所以hbase只会访问单一节点的hdfs 的 `/hbase/WALs/` 目录，导致冲突。解决方案是：请清除hbase安装目录下logs文件夹以hbase开头的所有日志文件，进入zkCli.sh客户端，并用`rmr /hbase`删除所有关于hbase的表信息，并用`hdfs dfs -rmr /hbase`删除所有关于hbase的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n------\n\n持续更新中，后面会重新搭建一次Hadoop+zookeeper+HBase集群，并记录所有Bug。\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["HBase"],"categories":["BUG记录"]},{"title":"Centos命令提示符显示完整路径","url":"/2019/05/04/Centos命令提示符显示完整路径/","content":"\n## 前言\n\nLinux下，命令行显示路径仅最后一个文件名，非常不方便， 最近在学大数据的时候才偶然发现这个小细节，简直太省心了，记录一下。\n\n## Centos命令提示符显示完整路径\n\n#### 1、编辑`[/etc/profile]`文件，在末尾添加环境变量PS1\n\n```shell\nexport PS1='[\\u@\\h `pwd`]\\$'\t\n```\n\n#### 2、刷新配置文件，使其生效\n\n```shell\n$> source /etc/profile\n```\n\n```shell\n命令释义：\n\\u 显示当前用户账号\n\\h 显示当前主机名\n\\W 只显示当前路径最后一个目录\n\\w 显示当前绝对路径（当前用户目录会以 ~代替）\npwd 显示当前全路径\n\\$ 显示命令行’$'或者’#'符号\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/20190504205919.png)\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n","tags":["Linux"],"categories":["技术支持"]},{"title":"Java短信微服务开发 SpringBoot + ActiveMQ + 腾讯云SMS","url":"/2019/04/02/Java短信微服务开发 SpringBoot+ActiveMQ+腾讯云SMS/","content":"\n\n\n## 前沿\n\n在去年学习Java的WEB开发时，就慢慢变得上瘾起来，不太愿意用视频中给的静态网页来做项目。自己便用不太熟练的JS写了个注册网页，然后还用上了邮箱验证码，很喜欢这个网页。但是后来的项目一直用不上，直到最近做一个网站，刚好可以用到之前做的注册网页。就把它用更高级的Angular JS改造了一下，并改成了手机短信验证码，感觉更有成就感了！\n\n此次开发的短信微服务是利用SpringBoot快速搭建ActiveMQ，因为我的云服务器和域名都在腾讯云，而且腾讯云短信每个月送100条短信，对我日常开发测试而言，根本用不完，所以使用腾讯云短信API完成发送短信，里面有好多技术都是第一次接触，所以写一下记录下细节。\n\n## 项目架构\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/架构.png)\n\n## 利用SpringBoot搭建ActiveMQ\n\n#### 1、创建Maven工程 letttgaco_sms_service（注意：打包方式为jar）\n\n添加如下依赖至pom.xml\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>cn.letttgaco.sms</groupId>\n\t<artifactId>letttgaco_sms_service</artifactId>\n\t<version>1.0</version>\n    <!-- 用Eclipse建SpringBoot项目会默认为jdk1.6 这里调整为jdk1.7 -->\n\t<properties>\n\t\t<java.version>1.7</java.version>\n\t</properties>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>1.4.0.RELEASE</version>\n\t</parent>\n\t<dependencies>\n        <!-- 起步依赖 SpringBoot核心部分就是依赖传递，它会自动引入WEB开发所需要的所有包，\n\t\t\t甚至连tomcat都内置了，所以这也是它搭建如此之快的原因了-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<!-- activtemq 只需要引入这一个依赖，它就会把所有用到的关联jar包都依赖传递过来-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-activemq</artifactId>\n\t\t</dependency>\n\t\t<!-- 腾讯云短信API -->\n\t\t<dependency>\n\t\t\t<groupId>com.github.qcloudsms</groupId>\n\t\t\t<artifactId>qcloudsms</artifactId>\n\t\t\t<version>1.0.6</version>\n\t\t</dependency>\n        <!-- springboot热部署 除了改pom文件，其他文件改了都不用重启，简直节省大量时间啊-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-devtools</artifactId>\n\t\t</dependency>\n\t</dependencies>\n</project>\n```\n\n#### 2、创建引导类Application.java\n\n这个类是程序的入口，启动它就能启动SpringBoot容器\n\n```java\npackage cn.letttgaco.sms;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n//@SpringBootApplication其实就是以下三个注解的总和\n//@Configuration： 用于定义一个配置类\n//@EnableAutoConfiguration ：Spring Boot会自动根据你jar包的依赖来自动配置项目。\n//@ComponentScan： 告诉Spring 哪个packages 的用注解标识的类 会被spring自动扫描并且装入bean容器。\npublic class Application {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n}\n```\n\n#### 3、使用腾讯云SMS需要准备的信息\n\n在腾讯云开通短信服务，申请好短信签名和短信模板后，可以将相关配置储存到配置文件application.properties（直接在resources中创建）中。[点击前往腾讯云短信官方文档](https://cloud.tencent.com/document/product/382/18071)\n\n```java\n\t// 短信应用SDK AppID\n\tint appid = 1400xxxx; // 1400开头\n\n    // 短信应用SDK AppKey\n    String appkey = \"qwertyuiopasdfghjkl123456789\";\n\n    // 需要发送短信的手机号码\n    String[] phoneNumbers = {\"21212313123\", \"12345678902\", \"12345678903\"};\n\n    // 短信模板ID，需要在短信应用中申请\n    int templateId = 7839; // NOTE: 这里的模板ID`7839`只是一个示例，真实的模板ID需要在短信控制台中申请\n    // 签名\n    String smsSign = \"腾讯云\"; // NOTE: 签名参数使用的是`签名内容`，而不是`签名ID`。这里的签名\"腾讯云\"只是一个示例，真实的签名需要在短信控制台申请。\n```\n\n\n\n#### 4、创建腾讯云SMS工具类SmsUtil.java\n\n```java\npackage cn.letttgaco.sms;\n\nimport java.io.IOException;\nimport java.util.Map;\n\nimport org.json.JSONException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.env.Environment;\nimport org.springframework.stereotype.Component;\n\nimport com.github.qcloudsms.SmsMultiSender;\nimport com.github.qcloudsms.SmsMultiSenderResult;\nimport com.github.qcloudsms.httpclient.HTTPException;\n@Component\npublic class SmsUtil {\n\t//用来读取springboot的配置文件中的内容\n\t@Autowired\n\tprivate Environment env;\n    \n\t/**\n\t * 我只在配置文件中存储了appid和appkey,其他信息我选择从上层传过来\n\t * @param map\n\t */\n\tpublic void sendSms(Map<String,String> map) {\n\t\ttry {\n\t\t\t//因为我这里只会用到单个手机号，所以用map传输\n\t\t\tString phone = map.get(\"phone\");\n\t\t\tint templateId = Integer.parseInt(map.get(\"templateId\"));\n\t\t\tString smsSign = map.get(\"smsSign\");\n            //多个手机号可以在数组中填写多个\n\t\t\tString[] phoneNumbers = {phone};\n\t\t\tString code = map.get(\"code\");\n            //我的短信模板是“欢迎注册，{1}为您的验证码,请于5分钟内填写。”\n            //{1}对应下面数组中的第一个信息\n\t\t\tString[] params = { code };// 对应模板中的内容\n\t\t\t//从配置文件中获取信息\n\t\t\tint appid = Integer.parseInt(env.getProperty(\"appid\"));\n\t\t\tString appkey = env.getProperty(\"appkey\");\n\t\t\tSmsMultiSender msender = new SmsMultiSender(appid,appkey);\n\t\t\t// 签名参数未提供或者为空时，会使用默认签名发送短信\n\t\t\tSmsMultiSenderResult result = msender.sendWithParam(\"86\", phoneNumbers,templateId, params, smsSign, \"\", \"\");\n\t\t\tSystem.out.println(result);\n\t\t} catch (HTTPException e) {\n\t\t\t// HTTP响应码错误\n\t\t\te.printStackTrace();\n\t\t} catch (JSONException e) {\n\t\t\t// json解析错误\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// 网络IO错误\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n\n```\n\n#### 5、创建消息的消费者SmsListener.java\n\n利用SpringBoot甚至不用配置ActiveMQ的xml文件！！！！\n\n```java\npackage cn.letttgaco.sms;\n\nimport java.util.Map;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jms.annotation.JmsListener;\nimport org.springframework.stereotype.Component;\n/**\n * 消息的消费端,监听消息\n * @author LetTTGACO\n *\n */\n@Component\npublic class SmsListener {\n\t\n\t@Autowired\n\tprivate SmsUtil smsUtil;\n\t//destination=\"sendSms\"指消费端会监听名称为sendSms的队列\n\t@JmsListener(destination=\"sendSms\")\n\tpublic void sendSms(Map<String,String> map) {\n\t\tsmsUtil.sendSms(map);\n\t}\n\n}\n\n```\n\n#### 6、创建消息的生产者\n\n```java\npackage cn.letttgaco.user.service.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.jms.core.JmsMessagingTemplate;\n\nimport com.alibaba.dubbo.config.annotation.Service;\n\n\n/**\n * 消息的生产者\n * @author LetTTGACO\n *\n */\n@RestController\npublic class UserServiceImpl implements UserService {\n\t\n    @Autowired\n\tprivate JmsMessagingTemplate jmsMessagingTemplate;\n    \n\t@Value(\"${templateId}\")\n\tprivate String templateId;\n\t\n\t@Value(\"${smsSign}\")\n\tprivate String smsSign;\n\t\n\t@RequestMapping(\"/sendSms\")\n\tpublic void sendSms(String phone) {\n\t\t//将短信内容发送给ActiveMQ\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tmap.put(\"phone\", phone);//手机号\n\t\tmap.put(\"templateId\", templateId);//签名模板\n\t\tmap.put(\"smsSign\", smsSign);//签名内容\n\t\tjmsMessagingTemplate.convertAndSend(\"sendSms\",phone);\n\t\t\n\t}\n\t\n}\n\n```\n\n## 测试\n\n> 注：可以在application.properties设置内置tomcat的访问端口号，默认为8080。\n\n```xml\nserver.port=9080\n```\n\n1、启动Application.java\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/springboot启动.png)\n\n2、打开浏览器\n\n输入`http://localhost:9080/sendSms?phone=13333333333` \n\n消息产生过程：\n\n（1）浏览器访问到控制层sendSms()方法产生消息，并推送给ActiveMQ。\n\n（2）消费者监听消息，接收ActiveMQ的消息，执行发送短信的任务。\n\n（3）手机收到短信\n\n------\n\n至此，短信微服务搭建成功！\n\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["微服务"],"categories":["教程"]},{"title":"在腾讯云服务器上安装FastDFS","url":"/2019/02/21/在腾讯云服务器上安装FastDFS/","content":"\n## 引言\n\nFastDFS 是一个由 C 语言实现的开源轻量级分布式文件系统，作者余庆[@YuQing](https://github.com/happyfish100)，支持 Linux、FreeBSD、AID 等 Unix 系统，解决了大数据存储和读写负载均衡等问题，适合存储 4KB~500MB 之间的小文件，如图片网站、短视频网站、文档、app 下载站等，UC、京东、支付宝、迅雷、酷狗等都有使用。\n\n## 安装前准备\n\n我的云服务器为腾讯云服务器，系统为CentOS7.2(64位)，自带50G系统盘。\n\n## 安装FastDFS\n\n### 1、上传安装包\n\n此次用到的安装包如图所示，我们首先用FTP工具把FastDFS([点击下载安装包](https://files.letttgaco.cn/技术支持/FastDFS/))的相关安装包上传至服务器的`/usr/local/fastDFS`目录中（也可以自行选择目录，后面在涉及到修改配置文件时会进一步提示说明）。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/FastDFS安装包.png)\n\n### 2、安装基本环境\n\n```shell\nyum -y install libevent\n```\n\n### 3、安装libfastcommonV1.0.7工具包\n\n```shell\ntar -zxvf libfastcommonV1.0.7.tar.gz\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/lib1.png)\n\n进入解压后的目录，看到有`make.sh`，依次执行命令进行编译。\n\n```shell\n./make.sh\n./make.sh install\n```\n### 4、安装Tracker服务\n\n```shell\ntar -zxvf FastDFS_v5.05.tar.gz\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/trackerd.png)\n\n进入文件夹后依次执行命令进行编译:\n\n```\n./make.sh\n./make.sh install\n```\n\n安装后文件会默认安装在 `/usr/bin` 中:\n\n```shell\nll fdfs*\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/usrbin.png)\n\n配置文件在 `/etc/fdfs`目录中：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/etcfdfs.png)\n\n进入`/usr/locla/fastDFS/FastDFS/conf/`目录下:\n\n```shell\ncd /usr/locla/fastDFS/FastDFS/conf/\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/conf.png)\n\n将其所有文件拷贝至`/etc/fdfs`目录下:\n\n```shell\ncp * /etc/fdfs/\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/cpconf.png)\n\n配置tracker服务,进入`/etc/fdfs/`目录下，修改`tracker.conf`文件\n\n```\ncd /etc/fdfs/\nvim tracker.conf\n```\n\n修改`base_path`为自定义存放tracker日志的目录，这里以`/usr/local/fastDFS/trackerLog`为例，如果没有创建此目录，可以先修改再创建。\n\n```shell\nmkdir -p /usr/local/fastDFS/trackerLog\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/basepath.png)\n\n> 这里我们也可以挂载的一个云硬盘，使用云硬盘的目录来存放文件。因为系统盘不支持扩容，以后系统盘满了之后就很麻烦，所以最好就挂载一个硬盘，同时也可以把图片文件都和系统盘给区分开来。我暂时没有云硬盘，这里以系统盘为例。\n>\n\n启动tracker服务并查看进程是否已启动\n\n```shell\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf\n```\n\n```\nps aux|grep trackerd\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/tracker.png)\n\n### 5、安装storage服务\n\n进入`/etc/fdfs/`目录，修改`storage.conf`文件\n\n```shell\nvim /etc/fdfs/storage.conf\n```\n\n修改日志的存储路径，如果没有相关文件夹，可以先配置再创建：\n\n```shell\nmkdir -p /usr/local/fastDFS/storageLog/\n```\n\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/storage1.png)\n\n修改文件的存储路径：\n\n```shell\nmkdir -p /usr/local/fastDFS/storage/\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/path0.png)\n\n\n\n修改`tracker_server` 的值为云服务器的公网IP地址。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/tracker_server1.png)\n\n启动storage服务并且查看进程：\n\n```shell\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf\n```\n\n```shell\nps aux|grep storage\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/startstorage.png)\n\n至此，FastDFS安装完毕，但是我们需要通过http来进行上传文件并访问，所以需要使用nginx一起来搞事情！\n\n### 6、安装nginx\n\n进入`/usr/local/fastDFS`目录，解压缩fastdfs-nginx-module_v1.16.tar.gz\n\n```shell\ntar -zxvf fastdfs-nginx-module_v1.16.tar.gz\n```\n\n修改`/fastdfs-nginx-module/src/config`文件，把其中的`local`去掉:\n\n```shell\ncd fastdfs-nginx-module/src/\n```\n\n```shell\nvim config\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/nginxfastdfs.png)\n\n创建默认的nginx的安装目录：\n\n```shell\nmkdir /usr/local/nginx/\n```\n\n进入nginx根目录进行配置：\n\n```shell\ncd /usr/local/fastDFS/nginx-1.14.2/\n```\n\n直接输入以下命令对nginx进行配置:\n\n> **注意：最后一行`--add-module=/usr/local/fastDFS/nginx/fastdfs-nginx-module/src`的目录为你所指定的`fastdfs-nginx-module`的安装目录**\n\n```shell\n./configure \\\n--prefix=/usr/local/nginx \\\n--pid-path=/var/run/nginx/nginx.pid \\\n--lock-path=/var/lock/nginx.lock \\\n--error-log-path=/var/log/nginx/error.log \\\n--http-log-path=/var/log/nginx/access.log \\\n--with-http_gzip_static_module \\\n--http-client-body-temp-path=/var/temp/nginx/client \\\n--http-proxy-temp-path=/var/temp/nginx/proxy \\\n--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\\n--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\\n--http-scgi-temp-path=/var/temp/nginx/scgi \\\n--add-module=/usr/local/fastDFS/nginx/fastdfs-nginx-module/src\n```\n\n依次执行以下命令进行编译：\n\n```shell\nmake\nmake install\n```\n\n把`/fastdfs-nginx-module/src/mod_fastdfs.conf`文件复制到`/etc/fdfs`目录下：\n\n```shell\ncd /usr/local/fastDFS/nginx/fastdfs-nginx-module/src/\n```\n\n```shell\ncp mod_fastdfs.conf /etc/fdfs\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/modconf.png)\n\n进入`/etc/fdfs/`，打开`mod_fastdfs.conf`并且修改日志存放路径：\n\n```shell\nmkdir -p /usr/local/fastDFS/tmp/\n```\n\n```shell\ncd /etc/fdfs/\n```\n\n```shell\nvim mod_fastdfs.conf\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/basepath1.png)\n\n修改`tracker_server` 的值为云服务器的公网IP地址。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/tracker_server2.png)\n\n修改`storage_path0`的存放路径：\n\n```shell\nmkdir -p /usr/local/fastDFS/storage/\n```\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/storage_path0.png)\n\n进入ngxin的配置文件目录并且修改`nginx.conf`文件：\n\n```shell\ncd /usr/local/nginx/conf/\n```\n\n```shell\nvim nginx.conf\n```\n\n修改原server中的配置为以下：\n\n```xml\nserver {\n        listen       80;\n        server_name  你的公网IP地址;\n\n        location /group1/M00 {\n            ngx_fastdfs_module;\n        }\n}\n```\n\n启动nginx\n\n```shell\n/usr/local/nginx/sbin/nginx \n```\n\n## 安装完成\n\n至此，FastDFS已全部安装完成，下面将介绍如何利用java开发工具来测试FastDFS的上传文件功能。\n\n## 上传测试\n\n需求：将本地图片上传至图片服务器，再控制台打印url。\n\n### 1、创建Maven工程FastDFSTest\n\n由于FastDFS客户端jar包并没有在中央仓库中，所以需要使用下列命令手动安装jar包到Maven本地仓库。\n\n源码地址：[fastdfs-client-java](https://github.com/happyfish100/fastdfs-client-java)，解压后导入Eclipse的Maven工程，右键项目选择`Run As — Maven Install`进行本地仓库的安装。\n\n在你的`FastDFSTest`工程的`pom.xml`中添加依赖：\n\n```xml\n<dependency>\n    <groupId>org.csource</groupId>\n    <artifactId>fastdfs-client-java</artifactId>\n    <version>1.27-SNAPSHOT</version>\n</dependency>\n```\n\n### 2、在resources文件夹中创建`fdfs_client.conf`文件\n\n```shell\n# 连接超时时间\n# 默认30s\n\nconnect_timeout=30\n\n\n# 网络超时时间\n\n# 默认30秒30s\n\nnetwork_timeout=60\n\n\n# 工作文件夹，日志存在此（目录自定）\n\nbase_path=/home/yuqing/fastdfs\n\n# tracer server服务器地址列表，多个tracer server的话，分行列出\n\ntracker_server=你的公网IP:22122\n\n\n#日志级别\n\n### emerg for emergency\n\n### alert\n\n### crit for critical\n\n### error\n\n### warn for warning\n\n### notice\n\n### info\n\n### debug\n\nlog_level=info\n\n\n# 是否使用连接池\n\nuse_connection_pool = false\n\n\n# 连接闲置超时时间，连接如果闲置的时间超过本配置，则关闭次连接，单位秒\n\nconnection_pool_max_idle_time = 3600\n\n\n# 是否从tracer server读取fastdfs的参数，默认为false\n\nload_fdfs_parameters_from_tracker=false\n\n\n# 是否使用storage id 替换 ip，默认为false\n\n# 和tracker.conf该参数含义一样\n\n# 本配置只有在load_fdfs_parameters_from_tracker＝false时生效\n\n# 本配置默认为false\n\nuse_storage_id = false\n\n\n# 指定storage id的文件名，允许使用绝对路径\n\n# 和tracker.conf该参数含义一样\n\n# 本配置只有在load_fdfs_parameters_from_tracker＝false时生效\n\nstorage_ids_filename = storage_ids.conf\n \n\n#HTTP settings\n\nhttp.tracker_server_port=8080\n \n\n#引入HTTP相关配置\n\n##include http.conf\n```\n\n### 3、创建测试java类\n\n```java\npackage cn.letttgaco.fastdfs;\n\nimport org.csource.fastdfs.ClientGlobal;\nimport org.csource.fastdfs.StorageClient;\nimport org.csource.fastdfs.StorageServer;\nimport org.csource.fastdfs.TrackerClient;\nimport org.csource.fastdfs.TrackerServer;\n\npublic class TestDemo {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 1、加载配置文件（绝对路径），配置文件中的内容就是 tracker 服务的地址。\n\t\tClientGlobal.init(\"D:/Codes/Eclipse/Tiramisu/spring-security-demo/src/main/resources/fdfs_client.conf\");\n\t\t// 2、创建一个 TrackerClient 对象。直接 new 一个。\n\t\tTrackerClient trackerClient = new TrackerClient();\n\t\t// 3、使用 TrackerClient 对象创建连接，获得一个 TrackerServer 对象。\n\t\tTrackerServer trackerServer = trackerClient.getConnection();\n\t\t// 4、创建一个 StorageServer 的引用，值为 null\n\t\tStorageServer storageServer = null;\n\t\t// 5、创建一个 StorageClient 对象，需要两个参数 TrackerServer 对象、StorageServer 的引用\n\t\tStorageClient storageClient = new StorageClient(trackerServer, storageServer);\n\t\t// 6、使用 StorageClient 对象上传图片（绝对路径）。\n\t\t// 扩展名不带“.”\n\t\tString[] strings = storageClient.upload_file(\"D:/Codes/TestCodes/c.JPG\", \"jpg\", null);\n\t\t// 7、返回数组。包含组名和图片的路径。\n\t\tfor (String string : strings) {\n\t\t\tSystem.out.println(string);\n\t\t}\n\t}\n\n}\n```\n\n控制台输出如下结果：\n\n```java\ngroup1\nM00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg\n```\n\n### 4、打开浏览器查看已上传的图片\n\n```shell\nhttp://你的公网IP/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg\n```\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["FastDFS"],"categories":["技术支持"]},{"title":"Spring Security安全框架入门","url":"/2019/02/17/Spring Security安全框架入门/","content":"\n## 前沿\n\nSpring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IOC（Inversion of Control控制反转），DI（Dependency Injection 依赖注入）和AOP（Aspect Oriented Programming面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。\n\n### 1、pom.xml\n\n在spring framework常规依赖的基础上添加以下依赖：\n\n```xml\n<dependency>\n\t<groupId>org.springframework.security</groupId>\n\t<artifactId>spring-security-config</artifactId>\n\t<version>4.1.0.RELEASE</version>\n</dependency>\n<dependency>\n\t<groupId>javax.servlet</groupId>\n\t<artifactId>servlet-api</artifactId>\n\t<version>2.5</version>\n\t<scope>provided</scope>\n</dependency>\n```\n\n### 2、web.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns=\"http://java.sun.com/xml/ns/javaee\"\n\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n                        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n         version=\"2.5\">\n    <!-- security安全框架 -->\n\t<context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:spring-security.xml</param-value>\n\t</context-param>\n\t<listener>\n        <listener-class>\n            org.springframework.web.context.ContextLoaderListener\n        </listener-class>\n\t</listener>\t\n\t<filter>  \n        <filter-name>springSecurityFilterChain</filter-name>\n        <filter-class>\n            org.springframework.web.filter.DelegatingFilterProxy\n        </filter-class>\n\t</filter>  \n\t<filter-mapping>  \n        <filter-name>springSecurityFilterChain</filter-name>  \n        <url-pattern>/*</url-pattern>  \n\t</filter-mapping>\t\n</web-app>\n```\n\n### 3、spring-security.xml(静态设置账号密码)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd\">\n\n    <!-- 以下页面不被拦截 -->\n\t<http pattern=\"/login.html\" security=\"none\"></http>\n\t<!-- 页面拦截规则 -->\n\t<http use-expressions=\"false\">\n        <!-- intercept-url表示需要拦截的 -->\n        <!-- /**表示拦截所有,access中必须以\"ROLE_\"开头,后面的是自定的用户-->\n\t\t<intercept-url pattern=\"/**\" access=\"ROLE_TEST\" />\n        <!-- \n\t\t\tlogin-page：指定登录页面。\n\t\t\tauthentication-failure-url：指定了身份验证失败时跳转到的页面。\n\t\t\tdefault-target-url：指定了成功进行身份验证和授权后默认呈现给用户的页面。\n \t\t-->\n        <form-login login-page=\"/login.html\" default-target-url=\"/index.html\" authentication-failure-url=\"/error.html\"/>\n        <!-- 关闭CSRF,如果不加会出现错误 -->\n        <!-- CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。-->\n\t\t<csrf disabled=\"true\"/>\n        <!-- 如果你在系统中使用了框架页，需要设置框架页的策略为SAMEORIGIN -->\n        <headers>\n\t\t\t<frame-options policy=\"SAMEORIGIN\"/>\n\t\t</headers>\n\t</http>\n\n\t<!-- 认证管理器 -->\n\t<authentication-manager>\n\t\t<authentication-provider>\n\t\t\t<user-service>\n                <!-- 为方便测试,将账号密码固定了 -->\n\t\t\t\t<user name=\"admin\" password=\"123456\" authorities=\"ROLE_TEST\"/>\n\t\t\t</user-service>\t\t\n\t\t</authentication-provider>\t\n\t</authentication-manager>\n</beans:beans>\n```\n\n### 4、动态从数据库中获取账号密码\n\n#### （1）创建UserDetailsServiceImpl.java并实现UserDetailsService接口\n\n```java\npackage cn.letttgaco.service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\n\nimport cn.letttgaco.pojo.LoginUser;\n\npublic class UserDetailServiceImpl implements UserDetailsService {\n\n\tprivate SellerService sellerService;\n\n\tpublic void setSellerService(SellerService sellerService) {\n\t\tthis.sellerService = sellerService;\n\t}\n\n\tpublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\tSystem.out.println(\"通过UserDetailServiceImpl\");\n\t\t// 构建角色列表\n\t\tList<GrantedAuthority> grantAuths = new ArrayList<GrantedAuthority>();\n\t\t// 添加角色\n\t\tgrantAuths.add(new SimpleGrantedAuthority(\"ROLE_SELLER\"));\n\t\t//得到用户对象\t\t\n\t\tLoginUser user = userService.login(username);\n\t\tif (user != null) {\n\t\t\t// 返回具有一定角色对象的用户对象\n\t\t\treturn new User(username, user.getPassword(), grantAuths);\n\t\t\treturn null;\n\t\t}else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n```\n\n#### (2)spring-security.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\n\txmlns:beans=\"http://www.springframework.org/schema/beans\" \n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/security \n\thttp://www.springframework.org/schema/security/spring-security.xsd\n\thttp://code.alibabatech.com/schema/dubbo \n\thttp://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n\n\t<!-- 设置不登录也可以访问的页面 -->\n\t<http pattern=\"/*.html\" security=\"none\"></http>\n\t<http pattern=\"/css/**\" security=\"none\"></http>\n\t<http pattern=\"/img/**\" security=\"none\"></http>\n\t<http pattern=\"/js/**\" security=\"none\"></http>\n\t<!-- 放开用户注册入口 -->\n\t<http pattern=\"/user/register.do\" security=\"none\"></http>\n\n\t<!-- 页面拦截规则 use-expressions:是否启用SPEL表达式,默认为true -->\n\t<http use-expressions=\"false\">\n\t\t<!-- 当前用户必须有ROLE_USER的角色才可访问根目录及所属子目录的资源 -->\n\t\t<intercept-url pattern=\"/**\" access=\"ROLE_SELLER\" />\n\t\t<!-- 开启表单登录功能 -->\n\t\t<form-login login-page=\"/login.html\"\n\t\t\tdefault-target-url=\"/index.html\" authentication-failure-url=\"/login.html\"\n\t\t\talways-use-default-target=\"true\" />\n\t\t<!-- 关闭csrf -->\n\t\t<csrf disabled=\"true\" />\n\t\t<!-- 配置策略,使用框架页面 -->\n\t\t<headers>\n\t\t\t<frame-options policy=\"SAMEORIGIN\" />\n\t\t</headers>\n\t\t<logout />\n\t</http>\n\n\t<!-- 添加认证类 -->\n\t<beans:bean id=\"userDetailService\" class=\"cn.letttgaco.service.UserDetailServiceImpl\">\n\t\t<beans:property name=\"userService\" ref=\"userService\"></beans:property>\n\t</beans:bean>\n\n\t<!-- 认证管理器 -->\n\t<authentication-manager>\n\t\t<!-- 认证的提供者 -->\n\t\t<authentication-provider user-service-ref=\"userDetailService\"/>\n\t</authentication-manager>\n</beans:beans>\n```\n\n通过以上配置，用户在登陆页输入用户名和密码与数据库一致即可登陆。\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["Spring Security"],"categories":["教程"]},{"title":"注解式配置dubbo服务","url":"/2019/02/09/注解式配置dubbo服务/","content":"\n## 前沿\n\n之前在做项目时一直用的都是dubbo的xml配置，在调试时未防止连接超时，一般会在xml中设置超时时间，但是最近的项目试了下dubbo的注解配置，但是一时半会没找到利用注解配置来设置超时时间，于是找了找资料，整理出常用的dubbo的配置文件以及注解配置设置超时时间等属性。\n\n## 服务提供者\n\n### 1.applicationContext-service.xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://code.alibabatech.com/schema/dubbo\n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n        \n\t<!--发布dubbo服务 -->\n\t<!--提供方应用信息,用于计算依赖关系-->\n\t<dubbo:application name=\"tiramisu-sellergoods-service\" />\n\t<!--注册中心的地址-->\n\t<dubbo:registry protocol=\"zookeeper\" address=\"xxx.xxx.xxx.xxx:2181\" />\n\t<!--用于dubbo协议在20881端口暴露服务-->\n\t<dubbo:protocol name=\"dubbo\" port=\"20881\"/>\n    <!--配置dubbo注解扫描包路径-->\n\t<dubbo:annotation package=\"cn.tiramisu.sellergoods.service.impl\"/>\n</beans>\n```\n\n### 2.@Service实现类\n\n```java\nimport com.alibaba.dubbo.config.annotation.Service;\n\n//注意不是springframework的service\n@Service\npublic class TiramisuServiceImpl implements TiramisuService {\n    \n}\n```\n\n## 服务消费者\n\n### 1.springmvc.xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://code.alibabatech.com/schema/dubbo \n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n\n\t<!-- 引用dubbo服务 -->\n\t<dubbo:application name=\"tiramisu-manager-web\" />\n    <!--注册中心的地址-->\n\t<dubbo:registry address=\"zookeeper://xxx.xxx.xxx.xxx:2181\"/>\n    <!--配置dubbo注解扫描包路径-->\n\t<dubbo:annotation package=\"cn.letttgaco.manager.controller\" />  \t\n</beans>\n```\n\n### 2.@Reference注解\n\n```\nimport com.alibaba.dubbo.config.annotation.Reference;@RestController\n\n@Controller\npublic class BrandController {\n    //使用dubbo提供的reference注解，引用dubbo服务\n\t@Reference\n\tprivate TiramisuService tiramisuService; \n}\n```\n\n## @Service和@Reference的属性配置\n\n------\n\n#### 超时时间的设定\n\n在平时测试过程中，由于dubbo默认的超时时间为5000毫秒，无法很方便的进行测试，容易报超时异常，而在以前的xml配置dubbo时，经常这样配置客户端的超时时间：\n\n```xml\n<!--设置超时时间为30秒-->\n<dubbo:service interface=\"cn.letttgaco.order.service.OrderService\" ref=\"orderServiceImpl\" timeout=\"300000\"/>\n```\n\n但是现在用的是dubbo的注解形式，设置注解形式的超时时间是直接在注解中声明的：\n\n```java\n//都要设置超时时间为30秒\n//服务提供方\n@Service(timeout=300000)\n//服务消费者\n@Reference(timeout=300000)\n```\n\n当然还有更多的属性都可以设置，如果有需要的可以研究下。\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["dubbo"],"categories":["教程"]},{"title":"Mybatis分页插件警告解决办法","url":"/2019/02/08/Mybatis分页插件警告解决办法/","content":"\n在使用springmvc+mybatis分页插件pagehelper时，只在业务层引用了mybatis的分页插件的jar包而表现层接收时没有引用，会报这样的警告：\n\n```java\n警告: Hessian/Burlap: 'com.github.pagehelper.Page' is an unknown class in WebappClassLoader\ncontext:\ndelegate: false\nrepositories:\n----------> Parent Classloader:\nClassRealm[plugin>org.apache.tomcat.maven:tomcat7-maven-plugin:2.2\njava.lang.ClassNotFoundException: com.github.pagehelper.Page\n```\n\n解决办法：mybatis的分页pagehelper插件依赖于mybatis的相关jar包，因此解决办法是在表现层同时加入分页pagehelper的jar包和mybatis的相关jar包，如下:\n\n```xml\n<dependency>\n\t<groupId>org.mybatis</groupId>\n\t<artifactId>mybatis</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org.mybatis</groupId>\n\t<artifactId>mybatis-spring</artifactId>\n</dependency>\n<dependency>\n\t<groupId>com.github.miemiedev</groupId>\n\t<artifactId>mybatis-paginator</artifactId>\n</dependency>\n<dependency>\n\t<groupId>com.github.pagehelper</groupId>\n\t<artifactId>pagehelper</artifactId>\n</dependency>\n```\n\n\n\n<div class=\"post-about\">除另有声明外，本博客文章均采用 <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可</div>\n\n","tags":["Mybatis"],"categories":["BUG记录"]}]